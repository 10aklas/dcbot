<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>import discord
from discord.ext import commands
import asyncio
import datetime
import json
import os
import re
import random
import time
import logging
import aiohttp
import io
import matplotlib.pyplot as plt
from collections import defaultdict, Counter
from typing import Optional, Union, List, Dict, Tuple
from discord.ui import Button, View

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("bot.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("ModBot")

# Bot configuration
if not os.path.exists('config.json'):
    with open('config.json', 'w') as f:
        json.dump({
            "token": "YOUR_BOT_TOKEN_HERE",
            "prefix": "!",
            "log_channel_id": None,
            "mute_role_name": "Muted",
            "auto_mod": {
                "enabled": True,
                "spam_threshold": 5,
                "spam_interval": 5,
                "max_mentions": 5,
                "banned_words": [],
                "banned_links": [],
                "caps_percentage": 70,
                "caps_min_length": 8,
                "auto_actions": {
                    "spam": "mute",
                    "mass_mention": "mute",
                    "banned_word": "warn",
                    "banned_link": "warn",
                    "excessive_caps": "warn",
                    "raid_detection": "ban"
                }
            },
            "verification": {
                "enabled": False,
                "role_id": None,
                "channel_id": None,
                "message": "Welcome! Please type `!verify` to gain access to the server."
            },
            "welcome": {
                "enabled": False,
                "channel_id": None,
                "message": "Welcome {user} to {server}! You are member #{count}."
            },
            "goodbye": {
                "enabled": False,
                "channel_id": None,
                "message": "Goodbye {user}! We hope to see you again."
            },
            "raid_protection": {
                "enabled": True,
                "join_rate_threshold": 5,
                "join_rate_interval": 10,
                "account_age_days": 7,
                "lockdown_duration": 300
            },
            "backup": {
                "enabled": True,
                "interval_hours": 24
            },
            "auto_role": {
                "enabled": False,
                "role_ids": []
            }
        }, f, indent=4)
    print("Config file created. Please add your bot token to config.json")
    exit()

with open('config.json', 'r') as f:
    config = json.load(f)

# Setup bot with intents
intents = discord.Intents.default()
intents.members = True
intents.message_content = True
intents.presences = True
intents.reactions = True

bot = commands.Bot(command_prefix=config['prefix'], intents=intents, help_command=None)

# Create necessary folders
os.makedirs('data', exist_ok=True)
os.makedirs('backups', exist_ok=True)
os.makedirs('logs', exist_ok=True)

# Database classes
class DatabaseManager:
    def __init__(self, filename):
        self.filename = f"data/{filename}"
        self.data = self._load_data()
    
    def _load_data(self):
        if os.path.exists(self.filename):
            with open(self.filename, 'r') as f:
                return json.load(f)
        return {}
    
    def _save_data(self):
        with open(self.filename, 'w') as f:
            json.dump(self.data, f, indent=4)

class WarningManager(DatabaseManager):
    def __init__(self):
        super().__init__("warnings.json")
    
    def add_warning(self, guild_id, user_id, moderator_id, reason):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id not in self.data:
            self.data[guild_id] = {}
        
        if user_id not in self.data[guild_id]:
            self.data[guild_id][user_id] = []
        
        warning = {
            "moderator_id": str(moderator_id),
            "reason": reason,
            "timestamp": datetime.datetime.utcnow().isoformat()
        }
        
        self.data[guild_id][user_id].append(warning)
        self._save_data()
        return len(self.data[guild_id][user_id])
    
    def get_warnings(self, guild_id, user_id):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id not in self.data:
            return []
        
        if user_id not in self.data[guild_id]:
            return []
        
        return self.data[guild_id][user_id]
    
    def clear_warnings(self, guild_id, user_id):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id in self.data and user_id in self.data[guild_id]:
            count = len(self.data[guild_id][user_id])
            self.data[guild_id][user_id] = []
            self._save_data()
            return count
        return 0
    
    def remove_warning(self, guild_id, user_id, warning_index):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id in self.data and user_id in self.data[guild_id]:
            warnings_list = self.data[guild_id][user_id]
            if 0 <= warning_index < len(warnings_list):
                removed = warnings_list.pop(warning_index)
                self._save_data()
                return True, removed
        return False, None

class NoteManager(DatabaseManager):
    def __init__(self):
        super().__init__("notes.json")
    
    def add_note(self, guild_id, user_id, moderator_id, content):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id not in self.data:
            self.data[guild_id] = {}
        
        if user_id not in self.data[guild_id]:
            self.data[guild_id][user_id] = []
        
        note = {
            "moderator_id": str(moderator_id),
            "content": content,
            "timestamp": datetime.datetime.utcnow().isoformat()
        }
        
        self.data[guild_id][user_id].append(note)
        self._save_data()
        return len(self.data[guild_id][user_id])
    
    def get_notes(self, guild_id, user_id):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id not in self.data:
            return []
        
        if user_id not in self.data[guild_id]:
            return []
        
        return self.data[guild_id][user_id]
    
    def remove_note(self, guild_id, user_id, note_index):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id in self.data and user_id in self.data[guild_id]:
            notes_list = self.data[guild_id][user_id]
            if 0 <= note_index < len(notes_list):
                removed = notes_list.pop(note_index)
                self._save_data()
                return True, removed
        return False, None

class RoleMenu(DatabaseManager):
    def __init__(self):
        super().__init__("role_menus.json")
    
    def create_menu(self, guild_id, channel_id, message_id, title, description):
        guild_id = str(guild_id)
        
        if guild_id not in self.data:
            self.data[guild_id] = {}
        
        menu_id = str(message_id)
        self.data[guild_id][menu_id] = {
            "channel_id": channel_id,
            "title": title,
            "description": description,
            "roles": {}
        }
        self._save_data()
        return menu_id
    
    def add_role(self, guild_id, menu_id, emoji, role_id, description):
        guild_id = str(guild_id)
        menu_id = str(menu_id)
        
        if guild_id in self.data and menu_id in self.data[guild_id]:
            self.data[guild_id][menu_id]["roles"][emoji] = {
                "role_id": role_id,
                "description": description
            }
            self._save_data()
            return True
        return False
    
    def get_menu(self, guild_id, menu_id):
        guild_id = str(guild_id)
        menu_id = str(menu_id)
        
        if guild_id in self.data and menu_id in self.data[guild_id]:
            return self.data[guild_id][menu_id]
        return None
    
    def get_menu_by_message(self, guild_id, message_id):
        guild_id = str(guild_id)
        message_id = str(message_id)
        
        if guild_id in self.data and message_id in self.data[guild_id]:
            return self.data[guild_id][message_id]
        return None
    
    def get_role_by_emoji(self, guild_id, menu_id, emoji):
        guild_id = str(guild_id)
        menu_id = str(menu_id)
        
        if guild_id in self.data and menu_id in self.data[guild_id]:
            menu = self.data[guild_id][menu_id]
            if emoji in menu["roles"]:
                return menu["roles"][emoji]["role_id"]
        return None
    
    def get_all_menus(self, guild_id):
        guild_id = str(guild_id)
        
        if guild_id in self.data:
            return self.data[guild_id]
        return {}

class TempbanManager(DatabaseManager):
    def __init__(self):
        super().__init__("tempbans.json")
    
    def add_tempban(self, guild_id, user_id, moderator_id, reason, expiry_time):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id not in self.data:
            self.data[guild_id] = {}
        
        self.data[guild_id][user_id] = {
            "moderator_id": str(moderator_id),
            "reason": reason,
            "expiry": expiry_time.timestamp() if isinstance(expiry_time, datetime.datetime) else expiry_time,
            "timestamp": datetime.datetime.utcnow().isoformat()
        }
        self._save_data()
    
    def get_tempban(self, guild_id, user_id):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id in self.data and user_id in self.data[guild_id]:
            return self.data[guild_id][user_id]
        return None
    
    def remove_tempban(self, guild_id, user_id):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id in self.data and user_id in self.data[guild_id]:
            ban_data = self.data[guild_id][user_id]
            del self.data[guild_id][user_id]
            self._save_data()
            return ban_data
        return None
    
    def get_expired_bans(self):
        expired_bans = []
        current_time = datetime.datetime.utcnow().timestamp()
        
        for guild_id, guild_bans in self.data.items():
            for user_id, ban_data in list(guild_bans.items()):
                if current_time > ban_data["expiry"]:
                    expired_bans.append((guild_id, user_id))
        
        return expired_bans

class AutomodManager(DatabaseManager):
    def __init__(self):
        super().__init__("automod_cases.json")
        self.message_counts = defaultdict(lambda: [])
        self.user_mentions = defaultdict(lambda: [])
    
    def add_case(self, guild_id, user_id, case_type, action_taken, content=None):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id not in self.data:
            self.data[guild_id] = []
        
        case = {
            "user_id": user_id,
            "type": case_type,
            "action": action_taken,
            "content": content,
            "timestamp": datetime.datetime.utcnow().isoformat()
        }
        
        self.data[guild_id].append(case)
        
        # Keep only the last 1000 cases per guild
        if len(self.data[guild_id]) > 1000:
            self.data[guild_id] = self.data[guild_id][-1000:]
        
        self._save_data()
    
    def get_cases(self, guild_id, limit=100):
        guild_id = str(guild_id)
        
        if guild_id in self.data:
            return self.data[guild_id][-limit:]
        return []
    
    def get_user_cases(self, guild_id, user_id, limit=10):
        guild_id = str(guild_id)
        user_id = str(user_id)
        
        if guild_id in self.data:
            user_cases = [case for case in self.data[guild_id] if case["user_id"] == user_id]
            return user_cases[-limit:]
        return []
    
    def track_message(self, user_id, channel_id, message_id, timestamp):
        key = f"{user_id}_{channel_id}"
        self.message_counts[key].append((message_id, timestamp))
        
        # Clear old messages (older than 10 seconds)
        current_time = time.time()
        self.message_counts[key] = [(mid, ts) for mid, ts in self.message_counts[key] if current_time - ts < 10]
        
        return len(self.message_counts[key])
    
    def track_mentions(self, user_id, mentions_count, timestamp):
        self.user_mentions[user_id].append((mentions_count, timestamp))
        
        # Clear old mentions (older than 30 seconds)
        current_time = time.time()
        self.user_mentions[user_id] = [(count, ts) for count, ts in self.user_mentions[user_id] if current_time - ts < 30]
        
        total_mentions = sum(count for count, _ in self.user_mentions[user_id])
        return total_mentions

class StatsManager(DatabaseManager):
    def __init__(self):
        super().__init__("stats.json")
        self.active_users = defaultdict(lambda: defaultdict(int))
        self.command_usage = defaultdict(int)
        self.last_save = time.time()
    
    def log_command(self, command_name):
        self.command_usage[command_name] += 1
        
        # Save every 10 minutes
        if time.time() - self.last_save > 600:
            self._update_stats()
    
    def log_user_activity(self, guild_id, user_id):
        day_key = datetime.datetime.utcnow().strftime("%Y-%m-%d")
        self.active_users[str(guild_id)][day_key] = len(set(list(self.active_users[str(guild_id)].get(day_key, set())) + [str(user_id)]))
        
        # Save every 10 minutes
        if time.time() - self.last_save > 600:
            self._update_stats()
    
    def _update_stats(self):
        if "commands" not in self.data:
            self.data["commands"] = {}
        
        # Update command usage
        for cmd, count in self.command_usage.items():
            if cmd not in self.data["commands"]:
                self.data["commands"][cmd] = 0
            self.data["commands"][cmd] += count
        
        # Update active users
        if "active_users" not in self.data:
            self.data["active_users"] = {}
        
        for guild_id, days in self.active_users.items():
            if guild_id not in self.data["active_users"]:
                self.data["active_users"][guild_id] = {}
            
            for day, count in days.items():
                self.data["active_users"][guild_id][day] = count
        
        # Reset temporary counters
        self.command_usage = defaultdict(int)
        self.active_users = defaultdict(lambda: defaultdict(int))
        self.last_save = time.time()
        
        # Save to file
        self._save_data()
    
    def get_command_stats(self, limit=10):
        if "commands" not in self.data:
            return {}
        
        # Sort commands by usage
        sorted_commands = sorted(self.data["commands"].items(), key=lambda x: x[1], reverse=True)
        return dict(sorted_commands[:limit])
    
    def get_active_users_stats(self, guild_id, days=7):
        guild_id = str(guild_id)
        
        if "active_users" not in self.data or guild_id not in self.data["active_users"]:
            return {}
        
        # Get stats for the last X days
        end_date = datetime.datetime.utcnow()
        start_date = end_date - datetime.timedelta(days=days)
        
        date_range = []
        current_date = start_date
        while current_date <= end_date:
            date_range.append(current_date.strftime("%Y-%m-%d"))
            current_date += datetime.timedelta(days=1)
        
        result = {}
        for date_str in date_range:
            result[date_str] = self.data["active_users"][guild_id].get(date_str, 0)
        
        return result

class FilterManager(DatabaseManager):
    def __init__(self):
        super().__init__("filters.json")
    
    def add_word(self, guild_id, word, filter_type="banned_word"):
        guild_id = str(guild_id)
        
        if guild_id not in self.data:
            self.data[guild_id] = {"banned_words": [], "banned_links": []}
        
        if filter_type not in self.data[guild_id]:
            self.data[guild_id][filter_type] = []
        
        if word not in self.data[guild_id][filter_type]:
            self.data[guild_id][filter_type].append(word)
            self._save_data()
            return True
        return False
    
    def remove_word(self, guild_id, word, filter_type="banned_word"):
        guild_id = str(guild_id)
        
        if guild_id in self.data and filter_type in self.data[guild_id]:
            if word in self.data[guild_id][filter_type]:
                self.data[guild_id][filter_type].remove(word)
                self._save_data()
                return True
        return False
    
    def get_words(self, guild_id, filter_type="banned_word"):
        guild_id = str(guild_id)
        
        if guild_id in self.data and filter_type in self.data[guild_id]:
            return self.data[guild_id][filter_type]
        return []
    
    def check_message(self, guild_id, content):
        guild_id = str(guild_id)
        content_lower = content.lower()
        
        if guild_id not in self.data:
            return None, None
        
        # Check banned words
        for word in self.data[guild_id].get("banned_words", []):
            pattern = r'\b' + re.escape(word.lower()) + r'\b'
            if re.search(pattern, content_lower):
                return "banned_word", word
        
        # Check banned links
        for link in self.data[guild_id].get("banned_links", []):
            if link.lower() in content_lower:
                return "banned_link", link
        
        return None, None

class LockdownManager(DatabaseManager):
    def __init__(self):
        super().__init__("lockdowns.json")
    
    def add_lockdown(self, guild_id, channel_id, original_overwrites, end_time=None):
        guild_id = str(guild_id)
        channel_id = str(channel_id)
        
        if guild_id not in self.data:
            self.data[guild_id] = {}
        
        # Save the overwrites as a JSON serializable format
        serializable_overwrites = {}
        for role_id, overwrite in original_overwrites.items():
            serializable_overwrites[str(role_id)] = {
                "send_messages": overwrite.send_messages,
                "send_messages_in_threads": overwrite.send_messages_in_threads,
                "create_public_threads": overwrite.create_public_threads,
                "create_private_threads": overwrite.create_private_threads
            }
        
        self.data[guild_id][channel_id] = {
            "overwrites": serializable_overwrites,
            "end_time": end_time.timestamp() if end_time else None,
            "timestamp": datetime.datetime.utcnow().isoformat()
        }
        self._save_data()
    
    def remove_lockdown(self, guild_id, channel_id):
        guild_id = str(guild_id)
        channel_id = str(channel_id)
        
        if guild_id in self.data and channel_id in self.data[guild_id]:
            lockdown_data = self.data[guild_id][channel_id]
            del self.data[guild_id][channel_id]
            self._save_data()
            return lockdown_data
        return None
    
    def get_lockdown(self, guild_id, channel_id):
        guild_id = str(guild_id)
        channel_id = str(channel_id)
        
        if guild_id in self.data and channel_id in self.data[guild_id]:
            return self.data[guild_id][channel_id]
        return None
    
    def get_all_lockdowns(self, guild_id):
        guild_id = str(guild_id)
        
        if guild_id in self.data:
            return self.data[guild_id]
        return {}
    
    def get_expired_lockdowns(self):
        expired_lockdowns = []
        current_time = datetime.datetime.utcnow().timestamp()
        
        for guild_id, channels in self.data.items():
            for channel_id, lockdown_data in list(channels.items()):
                if lockdown_data["end_time"] and current_time > lockdown_data["end_time"]:
                    expired_lockdowns.append((guild_id, channel_id))
        
        return expired_lockdowns

# Initialize database managers
warning_manager = WarningManager()
note_manager = NoteManager()
role_menu_manager = RoleMenu()
tempban_manager = TempbanManager()
automod_manager = AutomodManager()
stats_manager = StatsManager()
filter_manager = FilterManager()
lockdown_manager = LockdownManager()

# Recent joins tracking for raid protection
recent_joins = defaultdict(list)
server_lockdowns = {}

# Bot events
@bot.event
async def on_ready():
    logger.info(f'Logged in as {bot.user.name} (ID: {bot.user.id})')
    
    # Set bot presence
    await bot.change_presence(activity=discord.Activity(
        type=discord.ActivityType.watching, 
        name=f"{config['prefix']}help | Protecting {len(bot.guilds)} servers"
    ))
    
    # Start background tasks
    bot.loop.create_task(check_tempbans())
    bot.loop.create_task(check_temporary_lockdowns())
    
    if config["backup"]["enabled"]:
        bot.loop.create_task(backup_data())
    
    # Log stats on startup
    for guild in bot.guilds:
        logger.info(f"Serving {guild.name} (ID: {guild.id}) with {guild.member_count} members")

async def check_tempbans():
    """Background task to check for expired temporary bans"""
    await bot.wait_until_ready()
    while not bot.is_closed():
        expired_bans = tempban_manager.get_expired_bans()
        
        for guild_id, user_id in expired_bans:
            guild = bot.get_guild(int(guild_id))
            if not guild:
                continue
            
            ban_data = tempban_manager.remove_tempban(guild_id, user_id)
            
            try:
                # Unban the user
                user = await bot.fetch_user(int(user_id))
                await guild.unban(user, reason="Temporary ban expired")
                
                # Log the action
                await log_action(
                    guild=guild,
                    action="Unban (Auto)",
                    user=user,
                    moderator=guild.me,
                    reason="Temporary ban expired"
                )
                
                logger.info(f"Auto-unbanned user {user.name}#{user.discriminator} ({user.id}) from {guild.name}")
            except discord.NotFound:
                logger.warning(f"Could not find user {user_id} to unban from {guild.name}")
            except discord.Forbidden:
                logger.warning(f"No permission to unban {user_id} from {guild.name}")
        
        await asyncio.sleep(60)  # Check every minute

async def check_temporary_lockdowns():
    """Background task to check for expired temporary channel lockdowns"""
    await bot.wait_until_ready()
    while not bot.is_closed():
        expired_lockdowns = lockdown_manager.get_expired_lockdowns()
        
        for guild_id, channel_id in expired_lockdowns:
            guild = bot.get_guild(int(guild_id))
            if not guild:
                continue
            
            channel = guild.get_channel(int(channel_id))
            if not channel:
                continue
            
            lockdown_data = lockdown_manager.remove_lockdown(guild_id, channel_id)
            
            try:
                # Restore channel permissions
                for role_id, overwrite_data in lockdown_data["overwrites"].items():
                    role = guild.get_role(int(role_id))
                    if role:
                        overwrites = channel.overwrites_for(role)
                        overwrites.update(
                            send_messages=overwrite_data["send_messages"],
                            send_messages_in_threads=overwrite_data["send_messages_in_threads"],
                            create_public_threads=overwrite_data["create_public_threads"],
                            create_private_threads=overwrite_data["create_private_threads"]
                        )
                        await channel.set_permissions(role, overwrite=overwrites)
                
                # Log the action
                embed = discord.Embed(
                    title="Channel Unlocked",
                    description=f"{channel.mention} has been automatically unlocked.",
                    color=discord.Color.green(),
                    timestamp=datetime.datetime.utcnow()
                )
                await channel.send(embed=embed)
                
                # Log to mod channel
                await log_action(
                    guild=guild,
                    action="Unlock (Auto)",
                    channel=channel,
                    moderator=guild.me,
                    reason="Temporary lockdown expired"
                )
                
                logger.info(f"Auto-unlocked channel {channel.name} in {guild.name}")
            except discord.Forbidden:
                logger.warning(f"No permission to unlock channel {channel.name} in {guild.name}")
        
        # Check for server-wide lockdowns that need to be lifted
        current_time = time.time()
        for guild_id, data in list(server_lockdowns.items()):
            if current_time > data["end_time"]:
                guild = bot.get_guild(int(guild_id))
                if not guild:
                    continue
                
                try:
                    # Re-enable member verification
                    verification_level = data["previous_verification"]
                    await guild.edit(verification_level=verification_level)
                    
                    # Log the action
                    await log_action(
                        guild=guild,
                        action="Server Unlock (Auto)",
                        moderator=guild.me,
                        reason="Temporary server lockdown expired"
                    )
                    
                    del server_lockdowns[guild_id]
                    logger.info(f"Auto-unlocked server {guild.name}")
                except discord.Forbidden:
                    logger.warning(f"No permission to unlock server {guild.name}")
        
        await asyncio.sleep(60)  # Check every minute

async def backup_data():
    """Background task to backup database files"""
    await bot.wait_until_ready()
    while not bot.is_closed():
        backup_time = datetime.datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        backup_dir = f"backups/{backup_time}"
        os.makedirs(backup_dir, exist_ok=True)
        
        # Copy all data files to backup directory
        for file in os.listdir("data"):
            if file.endswith(".json"):
                source_path = f"data/{file}"
                target_path = f"{backup_dir}/{file}"
                with open(source_path, "r") as source:
                    with open(target_path, "w") as target:
                        target.write(source.read())
        
        # Keep only the last 30 backups
        backups = sorted(os.listdir("backups"))
        if len(backups) > 30:
            for old_backup in backups[:-30]:
                import shutil
                shutil.rmtree(f"backups/{old_backup}")
        
        logger.info(f"Backup created: {backup_time}")
        
        # Sleep for the configured interval
        await asyncio.sleep(config["backup"]["interval_hours"] * 3600)

# Helper functions
async def log_action(guild, action, user=None, moderator=None, reason=None, duration=None, channel=None, evidence=None):
    """Log moderation actions to the configured log channel"""
    if not config.get('log_channel_id'):
        return
    
    log_channel = guild.get_channel(int(config['log_channel_id']))
    if not log_channel:
        return
    
    embed = discord.Embed(
        title=f"Moderation Action: {action}",
        color=discord.Color.blue(),
        timestamp=datetime.datetime.utcnow()
    )
    
    if user:
        embed.add_field(name="User", value=f"{user.mention} ({user.name}#{user.discriminator if hasattr(user, 'discriminator') else '0'})", inline=True)
    
    if channel:
        embed.add_field(name="Channel", value=f"{channel.mention} ({channel.name})", inline=True)
    
    if moderator:
        embed.add_field(name="Moderator", value=f"{moderator.mention} ({moderator.name}#{moderator.discriminator if hasattr(moderator, 'discriminator') else '0'})", inline=True)
    
    if duration:
        embed.add_field(name="Duration", value=duration, inline=True)
    
    if reason:
        embed.add_field(name="Reason", value=reason, inline=False)
    
    if user:
        embed.set_footer(text=f"User ID: {user.id}")
        embed.set_thumbnail(url=user.display_avatar.url)
    elif channel:
        embed.set_footer(text=f"Channel ID: {channel.id}")
    
    message = await log_channel.send(embed=embed)
    
    # If there's evidence, add it as a file
    if evidence:
        if isinstance(evidence, str):
            # If evidence is a text string, create a file
            evidence_file = discord.File(io.StringIO(evidence), filename="evidence.txt")
            await log_channel.send(file=evidence_file)
        else:
            # Assume evidence is already a File object
            await log_channel.send(file=evidence)
    
    return message

def has_mod_role(ctx):
    """Check if user has a moderator role"""
    mod_roles = ["moderator", "mod", "admin", "administrator"]
    return any(role.name.lower() in mod_roles for role in ctx.author.roles) or ctx.author.guild_permissions.administrator

async def send_paginated_embed(ctx, title, pages, color=discord.Color.blue()):
    """Send a paginated embed for long content"""
    if not pages:
        await ctx.send("No content to display.")
        return
    
    current_page = 0
    
    embed = discord.Embed(title=title, description=pages[0], color=color)
    embed.set_footer(text=f"Page {current_page+1}/{len(pages)}")
    
    if len(pages) == 1:
        await ctx.send(embed=embed)
        return
    
    # Create a message with buttons
    view = discord.ui.View(timeout=120)
    
    # Previous button
    previous_button = discord.ui.Button(
        style=discord.ButtonStyle.secondary,
        emoji="⬅️",
        custom_id="previous"
    )
    
    # Next button
    next_button = discord.ui.Button(
        style=discord.ButtonStyle.secondary,
        emoji="➡️",
        custom_id="next"
    )
    
    async def button_callback(interaction):
        nonlocal current_page
        
        if interaction.data["custom_id"] == "previous":
            current_page = (current_page - 1) % len(pages)
        elif interaction.data["custom_id"] == "next":
            current_page = (current_page + 1) % len(pages)
        
        embed.description = pages[current_page]
        embed.set_footer(text=f"Page {current_page+1}/{len(pages)}")
        
        await interaction.response.edit_message(embed=embed)
    
    previous_button.callback = button_callback
    next_button.callback = button_callback
    
    view.add_item(previous_button)
    view.add_item(next_button)
    
    await ctx.send(embed=embed, view=view)

def split_text(text, max_length=4000):
    """Split text into chunks for pagination"""
    if len(text) <= max_length:
        return [text]
    
    chunks = []
    for i in range(0, len(text), max_length):
        chunks.append(text[i:i+max_length])
    
    return chunks

def parse_time(time_str):
    """Parse time string into seconds"""
    time_units = {
        's': 1,
        'm': 60,
        'h': 3600,
        'd': 86400,
        'w': 604800
    }
    
    # Default to seconds if no unit is provided
    if time_str.isdigit():
        return int(time_str)
    
    # Parse time with unit
    unit = time_str[-1].lower()
    if unit in time_units and time_str[:-1].isdigit():
        return int(time_str[:-1]) * time_units[unit]
    
    raise ValueError("Invalid time format. Use a number followed by s, m, h, d, or w.")

def format_time_delta(seconds):
    """Format a time delta in seconds to a human-readable string"""
    if seconds < 60:
        return f"{seconds} seconds"
    elif seconds < 3600:
        minutes = seconds // 60
        return f"{minutes} minutes"
    elif seconds < 86400:
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        return f"{hours} hours, {minutes} minutes"
    else:
        days = seconds // 86400
        hours = (seconds % 86400) // 3600
        return f"{days} days, {hours} hours"

# Moderation commands
@bot.command()
@commands.guild_only()
@commands.has_permissions(kick_members=True)
async def kick(ctx, member: discord.Member, *, reason="No reason provided"):
    """Kick a member from the server"""
    stats_manager.log_command("kick")
    
    if ctx.author.top_role <= member.top_role:
        return await ctx.send("You cannot kick someone with a role higher than or equal to yours.")
    
    try:
        # Send DM to the user
        kick_dm = discord.Embed(
            title=f"You've been kicked from {ctx.guild.name}",
            description=f"Reason: {reason}",
            color=discord.Color.red()
        )
        kick_dm.set_footer(text=f"Kicked by {ctx.author.name}#{ctx.author.discriminator}")
        
        try:
            await member.send(embed=kick_dm)
        except:
            await ctx.send("Note: Could not send a DM to the user.")
        
        # Kick the member
        await member.kick(reason=f"{ctx.author}: {reason}")
        
        # Log the action
        await log_action(ctx.guild, "Kick", member, ctx.author, reason)
        
        # Send confirmation
        embed = discord.Embed(
            title="Member Kicked",
            description=f"{member.mention} has been kicked from the server.",
            color=discord.Color.orange()
        )
        embed.add_field(name="Reason", value=reason)
        await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to kick that member.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(ban_members=True)
async def ban(ctx, member: Union[discord.Member, discord.User, int], *, reason="No reason provided"):
    """Ban a member from the server"""
    stats_manager.log_command("ban")
    
    try:
        # Handle different inputs for member
        if isinstance(member, int):
            try:
                member = await bot.fetch_user(member)
            except:
                return await ctx.send("Could not find a user with that ID.")
        
        # Check permissions if member is in the server
        if isinstance(member, discord.Member) and ctx.author.top_role <= member.top_role:
            return await ctx.send("You cannot ban someone with a role higher than or equal to yours.")
        
        # Send DM to the user if possible
        if isinstance(member, (discord.Member, discord.User)):
            ban_dm = discord.Embed(
                title=f"You've been banned from {ctx.guild.name}",
                description=f"Reason: {reason}",
                color=discord.Color.red()
            )
            ban_dm.set_footer(text=f"Banned by {ctx.author.name}#{ctx.author.discriminator}")
            
            try:
                await member.send(embed=ban_dm)
            except:
                await ctx.send("Note: Could not send a DM to the user.")
        
        # Ban the user
        await ctx.guild.ban(member, reason=f"{ctx.author}: {reason}", delete_message_days=1)
        
        # Log the action
        await log_action(ctx.guild, "Ban", member, ctx.author, reason)
        
        # Send confirmation
        embed = discord.Embed(
            title="User Banned",
            description=f"{member.mention} has been banned from the server.",
            color=discord.Color.red()
        )
        embed.add_field(name="Reason", value=reason)
        await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to ban that user.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(ban_members=True)
async def tempban(ctx, member: Union[discord.Member, discord.User, int], duration, *, reason="No reason provided"):
    """Temporarily ban a member for a specified duration"""
    stats_manager.log_command("tempban")
    
    try:
        # Convert duration to seconds
        try:
            duration_seconds = parse_time(duration)
            if duration_seconds <= 0:
                return await ctx.send("Duration must be a positive number.")
        except ValueError as e:
            return await ctx.send(str(e))
        
        # Handle different inputs for member
        if isinstance(member, int):
            try:
                member = await bot.fetch_user(member)
            except:
                return await ctx.send("Could not find a user with that ID.")
        
        # Check permissions if member is in the server
        if isinstance(member, discord.Member) and ctx.author.top_role <= member.top_role:
            return await ctx.send("You cannot ban someone with a role higher than or equal to yours.")
        
        # Calculate end time
        end_time = datetime.datetime.utcnow() + datetime.timedelta(seconds=duration_seconds)
        human_duration = format_time_delta(duration_seconds)
        
        # Send DM to the user if possible
        if isinstance(member, (discord.Member, discord.User)):
            ban_dm = discord.Embed(
                title=f"You've been temporarily banned from {ctx.guild.name}",
                description=f"Reason: {reason}\nDuration: {human_duration}",
                color=discord.Color.red()
            )
            ban_dm.set_footer(text=f"Banned by {ctx.author.name}#{ctx.author.discriminator}")
            
            try:
                await member.send(embed=ban_dm)
            except:
                await ctx.send("Note: Could not send a DM to the user.")
        
        # Ban the user
        await ctx.guild.ban(member, reason=f"{ctx.author}: {reason} (Temporary: {human_duration})", delete_message_days=1)
        
        # Store the temporary ban in the database
        tempban_manager.add_tempban(ctx.guild.id, member.id, ctx.author.id, reason, end_time)
        
        # Log the action
        await log_action(ctx.guild, "Temporary Ban", member, ctx.author, reason, human_duration)
        
        # Send confirmation
        embed = discord.Embed(
            title="User Temporarily Banned",
            description=f"{member.mention} has been banned from the server for {human_duration}.",
            color=discord.Color.red()
        )
        embed.add_field(name="Reason", value=reason)
        embed.add_field(name="Expires", value=f"<t:{int(end_time.timestamp())}:F>")
        await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to ban that user.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(ban_members=True)
async def unban(ctx, user_id: int, *, reason="No reason provided"):
    """Unban a user by ID"""
    stats_manager.log_command("unban")
    
    try:
        # Check if the user is banned
        try:
            ban_entry = await ctx.guild.fetch_ban(discord.Object(id=user_id))
            user = ban_entry.user
        except discord.NotFound:
            return await ctx.send(f"User with ID {user_id} is not banned.")
        
        # Remove from tempban list if it exists
        tempban_manager.remove_tempban(ctx.guild.id, user_id)
        
        # Unban the user
        await ctx.guild.unban(user, reason=f"{ctx.author}: {reason}")
        
        # Log the action
        await log_action(ctx.guild, "Unban", user, ctx.author, reason)
        
        # Send confirmation
        embed = discord.Embed(
            title="User Unbanned",
            description=f"{user.name}#{user.discriminator} has been unbanned from the server.",
            color=discord.Color.green()
        )
        embed.add_field(name="Reason", value=reason)
        await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to unban users.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_roles=True)
async def mute(ctx, member: discord.Member, duration: Optional[str] = None, *, reason="No reason provided"):
    """Mute a member (prevent them from sending messages)"""
    stats_manager.log_command("mute")
    
    if ctx.author.top_role <= member.top_role:
        return await ctx.send("You cannot mute someone with a role higher than or equal to yours.")
    
    try:
        # Find or create mute role
        mute_role = discord.utils.get(ctx.guild.roles, name=config['mute_role_name'])
        if not mute_role:
            # Create muted role
            mute_role = await ctx.guild.create_role(name=config['mute_role_name'], reason="Mute role for moderation")
            
            # Set permissions for the muted role in all text channels
            for channel in ctx.guild.channels:
                if isinstance(channel, discord.TextChannel):
                    await channel.set_permissions(mute_role, send_messages=False, add_reactions=False)
                elif isinstance(channel, discord.VoiceChannel):
                    await channel.set_permissions(mute_role, speak=False)
        
        # Add mute role to the member
        await member.add_roles(mute_role, reason=f"{ctx.author}: {reason}")
        
        # Calculate duration if provided
        if duration:
            try:
                duration_seconds = parse_time(duration)
                if duration_seconds <= 0:
                    return await ctx.send("Duration must be a positive number.")
                
                human_duration = format_time_delta(duration_seconds)
                end_time = datetime.datetime.utcnow() + datetime.timedelta(seconds=duration_seconds)
                
                # Send DM to the user
                mute_dm = discord.Embed(
                    title=f"You've been muted in {ctx.guild.name}",
                    description=f"Reason: {reason}\nDuration: {human_duration}",
                    color=discord.Color.orange()
                )
                mute_dm.set_footer(text=f"Muted by {ctx.author.name}#{ctx.author.discriminator}")
                
                try:
                    await member.send(embed=mute_dm)
                except:
                    await ctx.send("Note: Could not send a DM to the user.")
                
                # Log the action
                await log_action(ctx.guild, "Mute", member, ctx.author, reason, human_duration)
                
                # Send confirmation
                embed = discord.Embed(
                    title="Member Muted",
                    description=f"{member.mention} has been muted for {human_duration}.",
                    color=discord.Color.orange()
                )
                embed.add_field(name="Reason", value=reason)
                embed.add_field(name="Expires", value=f"<t:{int(end_time.timestamp())}:F>")
                await ctx.send(embed=embed)
                
                # Wait for the duration and then unmute
                await asyncio.sleep(duration_seconds)
                
                # Check if the member still has the mute role
                member = ctx.guild.get_member(member.id)  # Refresh member
                if member and mute_role in member.roles:
                    await member.remove_roles(mute_role, reason="Temporary mute expired")
                    
                    # Log the action
                    await log_action(ctx.guild, "Unmute (Auto)", member, ctx.guild.me, "Temporary mute expired")
                    
                    # Send notification
                    unmute_embed = discord.Embed(
                        title="Member Unmuted",
                        description=f"{member.mention} has been automatically unmuted after {human_duration}.",
                        color=discord.Color.green()
                    )
                    await ctx.send(embed=unmute_embed)
                    
                    # Send DM to the user
                    try:
                        unmute_dm = discord.Embed(
                            title=f"You've been unmuted in {ctx.guild.name}",
                            description="Your temporary mute has expired.",
                            color=discord.Color.green()
                        )
                        await member.send(embed=unmute_dm)
                    except:
                        pass
            
            except ValueError as e:
                await ctx.send(str(e))
                return
        else:
            # Indefinite mute
            mute_dm = discord.Embed(
                title=f"You've been muted in {ctx.guild.name}",
                description=f"Reason: {reason}\nDuration: Indefinite",
                color=discord.Color.orange()
            )
            mute_dm.set_footer(text=f"Muted by {ctx.author.name}#{ctx.author.discriminator}")
            
            try:
                await member.send(embed=mute_dm)
            except:
                await ctx.send("Note: Could not send a DM to the user.")
            
            # Log the action
            await log_action(ctx.guild, "Mute", member, ctx.author, reason)
            
            # Send confirmation
            embed = discord.Embed(
                title="Member Muted",
                description=f"{member.mention} has been muted indefinitely.",
                color=discord.Color.orange()
            )
            embed.add_field(name="Reason", value=reason)
            await ctx.send(embed=embed)
    
    except discord.Forbidden:
        await ctx.send("I don't have permission to manage roles or send messages to that user.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_roles=True)
async def unmute(ctx, member: discord.Member, *, reason="No reason provided"):
    """Unmute a member"""
    stats_manager.log_command("unmute")
    
    try:
        # Find mute role
        mute_role = discord.utils.get(ctx.guild.roles, name=config['mute_role_name'])
        if not mute_role:
            return await ctx.send("Mute role doesn't exist.")
        
        # Check if member is muted
        if mute_role not in member.roles:
            return await ctx.send(f"{member.mention} is not muted.")
        
        # Remove mute role
        await member.remove_roles(mute_role, reason=f"{ctx.author}: {reason}")
        
        # Log the action
        await log_action(ctx.guild, "Unmute", member, ctx.author, reason)
        
        # Send confirmation
        embed = discord.Embed(
            title="Member Unmuted",
            description=f"{member.mention} has been unmuted.",
            color=discord.Color.green()
        )
        embed.add_field(name="Reason", value=reason)
        await ctx.send(embed=embed)
        
        # Send DM to the user
        try:
            unmute_dm = discord.Embed(
                title=f"You've been unmuted in {ctx.guild.name}",
                description=f"Reason: {reason}",
                color=discord.Color.green()
            )
            unmute_dm.set_footer(text=f"Unmuted by {ctx.author.name}#{ctx.author.discriminator}")
            await member.send(embed=unmute_dm)
        except:
            await ctx.send("Note: Could not send a DM to the user.")
    
    except discord.Forbidden:
        await ctx.send("I don't have permission to manage roles.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_roles=True)
async def timeout(ctx, member: discord.Member, duration: str, *, reason="No reason provided"):
    """Timeout a member using Discord's timeout feature"""
    stats_manager.log_command("timeout")
    
    if ctx.author.top_role <= member.top_role:
        return await ctx.send("You cannot timeout someone with a role higher than or equal to yours.")
    
    try:
        # Convert duration to seconds
        try:
            duration_seconds = parse_time(duration)
            if duration_seconds <= 0:
                return await ctx.send("Duration must be a positive number.")
            
            # Discord limits timeouts to 28 days
            if duration_seconds > 2419200:  # 28 days in seconds
                return await ctx.send("Timeout duration cannot exceed 28 days.")
        except ValueError as e:
            return await ctx.send(str(e))
        
        # Calculate end time
        end_time = datetime.datetime.utcnow() + datetime.timedelta(seconds=duration_seconds)
        human_duration = format_time_delta(duration_seconds)
        
        # Apply timeout
        await member.timeout(until=end_time, reason=f"{ctx.author}: {reason}")
        
        # Send DM to the user
        timeout_dm = discord.Embed(
            title=f"You've been timed out in {ctx.guild.name}",
            description=f"Reason: {reason}\nDuration: {human_duration}",
            color=discord.Color.orange()
        )
        timeout_dm.set_footer(text=f"Timed out by {ctx.author.name}#{ctx.author.discriminator}")
        
        try:
            await member.send(embed=timeout_dm)
        except:
            await ctx.send("Note: Could not send a DM to the user.")
        
        # Log the action
        await log_action(ctx.guild, "Timeout", member, ctx.author, reason, human_duration)
        
        # Send confirmation
        embed = discord.Embed(
            title="Member Timed Out",
            description=f"{member.mention} has been timed out for {human_duration}.",
            color=discord.Color.orange()
        )
        embed.add_field(name="Reason", value=reason)
        embed.add_field(name="Expires", value=f"<t:{int(end_time.timestamp())}:F>")
        await ctx.send(embed=embed)
    
    except discord.Forbidden:
        await ctx.send("I don't have permission to timeout that member.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_roles=True)
async def removetimeout(ctx, member: discord.Member, *, reason="No reason provided"):
    """Remove a timeout from a member"""
    stats_manager.log_command("removetimeout")
    
    try:
        # Check if member is timed out
        if not member.is_timed_out():
            return await ctx.send(f"{member.mention} is not timed out.")
        
        # Remove timeout
        await member.timeout(until=None, reason=f"{ctx.author}: {reason}")
        
        # Log the action
        await log_action(ctx.guild, "Remove Timeout", member, ctx.author, reason)
        
        # Send confirmation
        embed = discord.Embed(
            title="Timeout Removed",
            description=f"{member.mention}'s timeout has been removed.",
            color=discord.Color.green()
        )
        embed.add_field(name="Reason", value=reason)
        await ctx.send(embed=embed)
        
        # Send DM to the user
        try:
            remove_timeout_dm = discord.Embed(
                title=f"Your timeout in {ctx.guild.name} has been removed",
                description=f"Reason: {reason}",
                color=discord.Color.green()
            )
            remove_timeout_dm.set_footer(text=f"Timeout removed by {ctx.author.name}#{ctx.author.discriminator}")
            await member.send(embed=remove_timeout_dm)
        except:
            await ctx.send("Note: Could not send a DM to the user.")
    
    except discord.Forbidden:
        await ctx.send("I don't have permission to manage timeouts.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def warn(ctx, member: discord.Member, *, reason="No reason provided"):
    """Warn a member"""
    stats_manager.log_command("warn")
    
    if ctx.author.top_role <= member.top_role:
        return await ctx.send("You cannot warn someone with a role higher than or equal to yours.")
    
    try:
        # Add warning to database
        warning_count = warning_manager.add_warning(ctx.guild.id, member.id, ctx.author.id, reason)
        
        # Get user's warning history
        warnings = warning_manager.get_warnings(ctx.guild.id, member.id)
        
        # Auto-moderate based on warning count
        punishment = None
        if len(warnings) == 3:
            # Auto-mute after 3 warnings
            punishment = "You have been muted for 1 hour due to receiving 3 warnings."
            mute_role = discord.utils.get(ctx.guild.roles, name=config['mute_role_name'])
            if not mute_role:
                mute_role = await ctx.guild.create_role(name=config['mute_role_name'])
                for channel in ctx.guild.channels:
                    if isinstance(channel, discord.TextChannel):
                        await channel.set_permissions(mute_role, send_messages=False, add_reactions=False)
                    elif isinstance(channel, discord.VoiceChannel):
                        await channel.set_permissions(mute_role, speak=False)
            
            await member.add_roles(mute_role, reason="Automatic mute: Received 3 warnings")
            await log_action(ctx.guild, "Mute (Auto)", member, ctx.guild.me, "Automatic mute: Received 3 warnings", "1 hour")
            
            # Schedule unmute
            bot.loop.create_task(auto_unmute(ctx.guild, member, mute_role, 3600))
        
        elif len(warnings) == 5:
            # Auto-kick after 5 warnings
            punishment = "You have been kicked due to receiving 5 warnings."
            await ctx.guild.kick(member, reason="Automatic kick: Received 5 warnings")
            await log_action(ctx.guild, "Kick (Auto)", member, ctx.guild.me, "Automatic kick: Received 5 warnings")
        
        elif len(warnings) >= 7:
            # Auto-ban after 7 warnings
            punishment = "You have been banned due to receiving 7 warnings."
            await ctx.guild.ban(member, reason="Automatic ban: Received 7 warnings", delete_message_days=1)
            await log_action(ctx.guild, "Ban (Auto)", member, ctx.guild.me, "Automatic ban: Received 7 warnings")
        
        # Log the action
        await log_action(ctx.guild, "Warning", member, ctx.author, reason)
        
        # Send confirmation
        embed = discord.Embed(
            title="Member Warned",
            description=f"{member.mention} has been warned.",
            color=discord.Color.gold()
        )
        embed.add_field(name="Reason", value=reason)
        embed.add_field(name="Warning Count", value=warning_count)
        
        if punishment:
            embed.add_field(name="Automatic Action", value=punishment, inline=False)
        
        await ctx.send(embed=embed)
        
        # Send DM to the user
        try:
            warn_dm = discord.Embed(
                title=f"Warning in {ctx.guild.name}",
                description=f"You have received a warning.",
                color=discord.Color.gold()
            )
            warn_dm.add_field(name="Reason", value=reason)
            warn_dm.add_field(name="Warning Count", value=warning_count)
            warn_dm.set_footer(text=f"Warning issued by {ctx.author.name}#{ctx.author.discriminator}")
            
            if punishment:
                warn_dm.add_field(name="Automatic Action", value=punishment, inline=False)
            
            await member.send(embed=warn_dm)
        except:
            await ctx.send("Note: Could not send a DM to the user.")
    
    except discord.Forbidden:
        await ctx.send("I don't have permission to manage messages or send DMs to that user.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

async def auto_unmute(guild, member, mute_role, duration):
    """Helper function to automatically unmute a member after a duration"""
    await asyncio.sleep(duration)
    
    # Check if the member still has the mute role
    member = guild.get_member(member.id)  # Refresh member
    if member and mute_role in member.roles:
        await member.remove_roles(mute_role, reason="Automatic unmute: Temporary mute expired")
        await log_action(guild, "Unmute (Auto)", member, guild.me, "Temporary mute expired")
        
        # Send DM to the user
        try:
            unmute_dm = discord.Embed(
                title=f"You've been unmuted in {guild.name}",
                description="Your temporary mute has expired.",
                color=discord.Color.green()
            )
            await member.send(embed=unmute_dm)
        except:
            pass  # Silently fail if DM can't be sent

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def warnings(ctx, member: discord.Member):
    """Show warnings for a member"""
    stats_manager.log_command("warnings")
    
    warnings = warning_manager.get_warnings(ctx.guild.id, member.id)
    
    if not warnings:
        return await ctx.send(f"{member.mention} has no warnings.")
    
    # Create paginated embeds for warnings
    embed = discord.Embed(
        title=f"Warnings for {member.name}#{member.discriminator}",
        color=discord.Color.gold()
    )
    
    for i, warning in enumerate(warnings, 1):
        moderator = ctx.guild.get_member(int(warning["moderator_id"]))
        moderator_name = moderator.name if moderator else "Unknown Moderator"
        
        timestamp = datetime.datetime.fromisoformat(warning["timestamp"])
        time_str = f"<t:{int(timestamp.timestamp())}:F>"
        
        embed.add_field(
            name=f"Warning #{i}",
            value=f"**Reason:** {warning['reason']}\n**Moderator:** {moderator_name}\n**Date:** {time_str}",
            inline=False
        )
    
    embed.set_thumbnail(url=member.display_avatar.url)
    embed.set_footer(text=f"Total Warnings: {len(warnings)}")
    
    await ctx.send(embed=embed)

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def clearwarnings(ctx, member: discord.Member):
    """Clear all warnings for a member"""
    stats_manager.log_command("clearwarnings")
    
    warnings_removed = warning_manager.clear_warnings(ctx.guild.id, member.id)
    
    if warnings_removed == 0:
        return await ctx.send(f"{member.mention} had no warnings to clear.")
    
    # Log the action
    await log_action(ctx.guild, "Clear Warnings", member, ctx.author, f"Cleared {warnings_removed} warnings")
    
    # Send confirmation
    embed = discord.Embed(
        title="Warnings Cleared",
        description=f"Cleared {warnings_removed} warnings for {member.mention}.",
        color=discord.Color.green()
    )
    await ctx.send(embed=embed)

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def removewarning(ctx, member: discord.Member, warning_id: int):
    """Remove a specific warning from a member"""
    stats_manager.log_command("removewarning")
    
    # Warning IDs are 1-indexed for user display but 0-indexed in storage
    index = warning_id - 1
    
    success, removed = warning_manager.remove_warning(ctx.guild.id, member.id, index)
    
    if not success:
        return await ctx.send(f"Could not find warning #{warning_id} for {member.mention}.")
    
    # Log the action
    await log_action(
        ctx.guild, 
        "Remove Warning", 
        member, 
        ctx.author, 
        f"Removed warning #{warning_id}: {removed['reason']}"
    )
    
    # Send confirmation
    embed = discord.Embed(
        title="Warning Removed",
        description=f"Removed warning #{warning_id} from {member.mention}.",
        color=discord.Color.green()
    )
    
    moderator = ctx.guild.get_member(int(removed["moderator_id"]))
    moderator_name = moderator.name if moderator else "Unknown Moderator"
    
    embed.add_field(name="Original Reason", value=removed["reason"])
    embed.add_field(name="Original Moderator", value=moderator_name)
    
    await ctx.send(embed=embed)

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def note(ctx, member: discord.Member, *, content):
    """Add a note about a member"""
    stats_manager.log_command("note")
    
    # Add note to database
    note_count = note_manager.add_note(ctx.guild.id, member.id, ctx.author.id, content)
    
    # Log the action
    await log_action(ctx.guild, "Note Added", member, ctx.author, content)
    
    # Send confirmation
    embed = discord.Embed(
        title="Note Added",
        description=f"Added note for {member.mention}.",
        color=discord.Color.blue()
    )
    embed.add_field(name="Content", value=content)
    embed.add_field(name="Note Count", value=note_count)
    
    await ctx.send(embed=embed)

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def notes(ctx, member: discord.Member):
    """Show notes for a member"""
    stats_manager.log_command("notes")
    
    notes = note_manager.get_notes(ctx.guild.id, member.id)
    
    if not notes:
        return await ctx.send(f"{member.mention} has no notes.")
    
    # Create paginated embeds for notes
    embed = discord.Embed(
        title=f"Notes for {member.name}#{member.discriminator}",
        color=discord.Color.blue()
    )
    
    for i, note in enumerate(notes, 1):
        moderator = ctx.guild.get_member(int(note["moderator_id"]))
        moderator_name = moderator.name if moderator else "Unknown Moderator"
        
        timestamp = datetime.datetime.fromisoformat(note["timestamp"])
        time_str = f"<t:{int(timestamp.timestamp())}:F>"
        
        embed.add_field(
            name=f"Note #{i}",
            value=f"**Content:** {note['content']}\n**Moderator:** {moderator_name}\n**Date:** {time_str}",
            inline=False
        )
    
    embed.set_thumbnail(url=member.display_avatar.url)
    embed.set_footer(text=f"Total Notes: {len(notes)}")
    
    await ctx.send(embed=embed)

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def removenote(ctx, member: discord.Member, note_id: int):
    """Remove a specific note from a member"""
    stats_manager.log_command("removenote")
    
    # Note IDs are 1-indexed for user display but 0-indexed in storage
    index = note_id - 1
    
    success, removed = note_manager.remove_note(ctx.guild.id, member.id, index)
    
    if not success:
        return await ctx.send(f"Could not find note #{note_id} for {member.mention}.")
    
    # Log the action
    await log_action(
        ctx.guild, 
        "Remove Note", 
        member, 
        ctx.author, 
        f"Removed note #{note_id}: {removed['content']}"
    )
    
    # Send confirmation
    embed = discord.Embed(
        title="Note Removed",
        description=f"Removed note #{note_id} from {member.mention}.",
        color=discord.Color.green()
    )
    
    moderator = ctx.guild.get_member(int(removed["moderator_id"]))
    moderator_name = moderator.name if moderator else "Unknown Moderator"
    
    embed.add_field(name="Original Content", value=removed["content"])
    embed.add_field(name="Original Moderator", value=moderator_name)
    
    await ctx.send(embed=embed)

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def purge(ctx, amount: int, *, user: discord.Member = None):
    """Delete a specified number of messages from a channel"""
    stats_manager.log_command("purge")
    
    if amount <= 0:
        return await ctx.send("Please provide a positive number of messages to delete.")
    
    if amount > 500:
        return await ctx.send("You can only delete up to 500 messages at once.")
    
    # Delete command message
    await ctx.message.delete()
    
    # Filter messages by user if specified
    def check(message):
        return user is None or message.author == user
    
    # Delete messages
    try:
        deleted = await ctx.channel.purge(limit=amount, check=check)
        
        # Log the action
        if user:
            reason = f"Purged {len(deleted)} messages from {user.name}"
        else:
            reason = f"Purged {len(deleted)} messages"
        
        await log_action(ctx.guild, "Purge", user, ctx.author, reason, channel=ctx.channel)
        
        # Send confirmation (will delete after 5 seconds)
        if user:
            message = await ctx.send(f"✅ Deleted {len(deleted)} messages from {user.mention}.")
        else:
            message = await ctx.send(f"✅ Deleted {len(deleted)} messages.")
        
        await asyncio.sleep(5)
        await message.delete()
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to delete messages.")
    except discord.HTTPException as e:
        await ctx.send(f"Error deleting messages: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_channels=True)
async def lock(ctx, channel: discord.TextChannel = None, *, reason="No reason provided"):
    """Lock a channel, preventing users from sending messages"""
    stats_manager.log_command("lock")
    
    channel = channel or ctx.channel
    
    try:
        # Get current overwrites to restore later
        original_overwrites = dict(channel.overwrites)
        
        # Lock the channel by denying send messages for @everyone
        everyone_role = ctx.guild.default_role
        overwrites = channel.overwrites_for(everyone_role)
        overwrites.update(send_messages=False, send_messages_in_threads=False, create_public_threads=False, create_private_threads=False)
        await channel.set_permissions(everyone_role, overwrite=overwrites)
        
        # Store the original permissions
        lockdown_manager.add_lockdown(ctx.guild.id, channel.id, original_overwrites)
        
        # Log the action
        await log_action(ctx.guild, "Lock", moderator=ctx.author, reason=reason, channel=channel)
        
        # Send confirmation
        embed = discord.Embed(
            title="Channel Locked",
            description=f"{channel.mention} has been locked.",
            color=discord.Color.red(),
            timestamp=datetime.datetime.utcnow()
        )
        embed.add_field(name="Reason", value=reason)
        embed.add_field(name="Locked by", value=ctx.author.mention)
        
        await channel.send(embed=embed)
        if channel != ctx.channel:
            await ctx.send(f"Channel {channel.mention} has been locked.")
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to manage channel permissions.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_channels=True)
async def unlock(ctx, channel: discord.TextChannel = None, *, reason="No reason provided"):
    """Unlock a previously locked channel"""
    stats_manager.log_command("unlock")
    
    channel = channel or ctx.channel
    
    try:
        # Get the original overwrites
        lockdown_data = lockdown_manager.get_lockdown(ctx.guild.id, channel.id)
        
        if not lockdown_data:
            return await ctx.send(f"{channel.mention} is not locked or was not locked using the bot.")
        
        # Restore original permissions
        for role_id, overwrite_data in lockdown_data["overwrites"].items():
            role = ctx.guild.get_role(int(role_id))
            if role:
                overwrites = channel.overwrites_for(role)
                overwrites.update(
                    send_messages=overwrite_data["send_messages"],
                    send_messages_in_threads=overwrite_data["send_messages_in_threads"],
                    create_public_threads=overwrite_data["create_public_threads"],
                    create_private_threads=overwrite_data["create_private_threads"]
                )
                await channel.set_permissions(role, overwrite=overwrites)
        
        # Remove from lockdown database
        lockdown_manager.remove_lockdown(ctx.guild.id, channel.id)
        
        # Log the action
        await log_action(ctx.guild, "Unlock", moderator=ctx.author, reason=reason, channel=channel)
        
        # Send confirmation
        embed = discord.Embed(
            title="Channel Unlocked",
            description=f"{channel.mention} has been unlocked.",
            color=discord.Color.green(),
            timestamp=datetime.datetime.utcnow()
        )
        embed.add_field(name="Reason", value=reason)
        embed.add_field(name="Unlocked by", value=ctx.author.mention)
        
        await channel.send(embed=embed)
        if channel != ctx.channel:
            await ctx.send(f"Channel {channel.mention} has been unlocked.")
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to manage channel permissions.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_channels=True)
async def slowmode(ctx, seconds: int, channel: discord.TextChannel = None, *, reason="No reason provided"):
    """Set slowmode for a channel"""
    stats_manager.log_command("slowmode")
    
    channel = channel or ctx.channel
    
    if seconds < 0:
        return await ctx.send("Slowmode seconds cannot be negative.")
    
    if seconds > 21600:  # Discord's maximum is 6 hours (21600 seconds)
        return await ctx.send("Slowmode cannot exceed 6 hours (21600 seconds).")
    
    try:
        await channel.edit(slowmode_delay=seconds)
        
        # Log the action
        await log_action(
            ctx.guild, 
            "Slowmode", 
            moderator=ctx.author, 
            reason=reason,
            channel=channel,
            duration=f"{seconds} seconds" if seconds > 0 else "Disabled"
        )
        
        # Send confirmation
        if seconds == 0:
            embed = discord.Embed(
                title="Slowmode Disabled",
                description=f"Slowmode has been disabled in {channel.mention}.",
                color=discord.Color.green()
            )
        else:
            embed = discord.Embed(
                title="Slowmode Enabled",
                description=f"Slowmode has been set to {seconds} seconds in {channel.mention}.",
                color=discord.Color.blue()
            )
        
        embed.add_field(name="Reason", value=reason)
        
        await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to edit the channel.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_guild=True)
async def lockserver(ctx, duration: Optional[str] = None, *, reason="No reason provided"):
    """Lock down the entire server by raising verification level"""
    stats_manager.log_command("lockserver")
    
    try:
        # Store current verification level
        previous_verification = ctx.guild.verification_level
        
        # Set verification to highest
        await ctx.guild.edit(verification_level=discord.VerificationLevel.highest)
        
        if duration:
            try:
                duration_seconds = parse_time(duration)
                if duration_seconds <= 0:
                    return await ctx.send("Duration must be a positive number.")
                
                end_time = time.time() + duration_seconds
                human_duration = format_time_delta(duration_seconds)
                
                # Store lockdown info
                server_lockdowns[ctx.guild.id] = {
                    "previous_verification": previous_verification,
                    "end_time": end_time,
                    "moderator": ctx.author.id,
                    "reason": reason
                }
                
                # Log the action
                await log_action(
                    ctx.guild, 
                    "Server Lockdown", 
                    moderator=ctx.author, 
                    reason=reason,
                    duration=human_duration
                )
                
                # Send confirmation
                embed = discord.Embed(
                    title="Server Locked Down",
                    description=f"Server has been locked down for {human_duration}.",
                    color=discord.Color.red()
                )
                embed.add_field(name="Reason", value=reason)
                embed.add_field(name="Expires", value=f"<t:{int(end_time)}:F>")
                
                await ctx.send(embed=embed)
                
            except ValueError as e:
                await ctx.send(str(e))
                # Revert verification level
                await ctx.guild.edit(verification_level=previous_verification)
                return
        else:
            # Log the action
            await log_action(
                ctx.guild, 
                "Server Lockdown", 
                moderator=ctx.author, 
                reason=reason
            )
            
            # Send confirmation
            embed = discord.Embed(
                title="Server Locked Down",
                description="Server has been locked down indefinitely.",
                color=discord.Color.red()
            )
            embed.add_field(name="Reason", value=reason)
            
            await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to edit the server.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_guild=True)
async def unlockserver(ctx, *, reason="No reason provided"):
    """Unlock the server by restoring previous verification level"""
    stats_manager.log_command("unlockserver")
    
    try:
        # Check if server is in timed lockdown
        if ctx.guild.id in server_lockdowns:
            previous_verification = server_lockdowns[ctx.guild.id]["previous_verification"]
            del server_lockdowns[ctx.guild.id]
        else:
            # If not in a timed lockdown, lower to low verification
            previous_verification = discord.VerificationLevel.low
        
        # Restore verification level
        await ctx.guild.edit(verification_level=previous_verification)
        
        # Log the action
        await log_action(
            ctx.guild, 
            "Server Unlock", 
            moderator=ctx.author, 
            reason=reason
        )
        
        # Send confirmation
        embed = discord.Embed(
            title="Server Unlocked",
            description="Server verification level has been restored.",
            color=discord.Color.green()
        )
        embed.add_field(name="Reason", value=reason)
        
        await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to edit the server.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def addword(ctx, word, *, reason="No reason provided"):
    """Add a word to the server's banned words filter"""
    stats_manager.log_command("addword")
    
    # Add the word to the filter
    if filter_manager.add_word(ctx.guild.id, word, "banned_words"):
        # Log the action
        await log_action(
            ctx.guild, 
            "Add Banned Word", 
            moderator=ctx.author, 
            reason=reason
        )
        
        # Send confirmation
        embed = discord.Embed(
            title="Banned Word Added",
            description=f"Added `{word}` to the server's banned words list.",
            color=discord.Color.green()
        )
        embed.add_field(name="Reason", value=reason)
        
        await ctx.send(embed=embed)
    else:
        await ctx.send(f"`{word}` is already in the banned words list.")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def removeword(ctx, word):
    """Remove a word from the server's banned words filter"""
    stats_manager.log_command("removeword")
    
    # Remove the word from the filter
    if filter_manager.remove_word(ctx.guild.id, word, "banned_words"):
        # Log the action
        await log_action(
            ctx.guild, 
            "Remove Banned Word", 
            moderator=ctx.author, 
            reason=f"Removed '{word}' from banned words list"
        )
        
        # Send confirmation
        embed = discord.Embed(
            title="Banned Word Removed",
            description=f"Removed `{word}` from the server's banned words list.",
            color=discord.Color.green()
        )
        
        await ctx.send(embed=embed)
    else:
        await ctx.send(f"`{word}` is not in the banned words list.")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def bannedwords(ctx):
    """List all banned words in the server"""
    stats_manager.log_command("bannedwords")
    
    # Get the list of banned words
    words = filter_manager.get_words(ctx.guild.id, "banned_words")
    
    if not words:
        return await ctx.send("There are no banned words in this server.")
    
    # Create paginated list
    pages = []
    current_page = []
    
    for i, word in enumerate(words, 1):
        current_page.append(f"{i}. `{word}`")
        
        if i % 15 == 0 or i == len(words):
            pages.append("\n".join(current_page))
            current_page = []
    
    # Send paginated embeds
    await send_paginated_embed(ctx, "Banned Words List", pages)

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def addlink(ctx, link, *, reason="No reason provided"):
    """Add a link to the server's banned links filter"""
    stats_manager.log_command("addlink")
    
    # Add the link to the filter
    if filter_manager.add_word(ctx.guild.id, link, "banned_links"):
        # Log the action
        await log_action(
            ctx.guild, 
            "Add Banned Link", 
            moderator=ctx.author, 
            reason=reason
        )
        
        # Send confirmation
        embed = discord.Embed(
            title="Banned Link Added",
            description=f"Added `{link}` to the server's banned links list.",
            color=discord.Color.green()
        )
        embed.add_field(name="Reason", value=reason)
        
        await ctx.send(embed=embed)
    else:
        await ctx.send(f"`{link}` is already in the banned links list.")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def removelink(ctx, link):
    """Remove a link from the server's banned links filter"""
    stats_manager.log_command("removelink")
    
    # Remove the link from the filter
    if filter_manager.remove_word(ctx.guild.id, link, "banned_links"):
        # Log the action
        await log_action(
            ctx.guild, 
            "Remove Banned Link", 
            moderator=ctx.author, 
            reason=f"Removed '{link}' from banned links list"
        )
        
        # Send confirmation
        embed = discord.Embed(
            title="Banned Link Removed",
            description=f"Removed `{link}` from the server's banned links list.",
            color=discord.Color.green()
        )
        
        await ctx.send(embed=embed)
    else:
        await ctx.send(f"`{link}` is not in the banned links list.")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_messages=True)
async def bannedlinks(ctx):
    """List all banned links in the server"""
    stats_manager.log_command("bannedlinks")
    
    # Get the list of banned links
    links = filter_manager.get_words(ctx.guild.id, "banned_links")
    
    if not links:
        return await ctx.send("There are no banned links in this server.")
    
    # Create paginated list
    pages = []
    current_page = []
    
    for i, link in enumerate(links, 1):
        current_page.append(f"{i}. `{link}`")
        
        if i % 15 == 0 or i == len(links):
            pages.append("\n".join(current_page))
            current_page = []
    
    # Send paginated embeds
    await send_paginated_embed(ctx, "Banned Links List", pages)

# Role menu commands
@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_roles=True)
async def createrole(ctx, name, color: Optional[discord.Color] = discord.Color.default(), *, reason="No reason provided"):
    """Create a new role in the server"""
    stats_manager.log_command("createrole")
    
    try:
        # Create the role
        role = await ctx.guild.create_role(name=name, color=color, reason=f"{ctx.author}: {reason}")
        
        # Log the action
        await log_action(
            ctx.guild, 
            "Create Role", 
            moderator=ctx.author, 
            reason=reason
        )
        
        # Send confirmation
        embed = discord.Embed(
            title="Role Created",
            description=f"Created role {role.mention}.",
            color=role.color
        )
        embed.add_field(name="Name", value=role.name)
        embed.add_field(name="Color", value=str(role.color))
        embed.add_field(name="ID", value=role.id)
        
        await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to manage roles.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_roles=True)
async def addrole(ctx, member: discord.Member, role: discord.Role, *, reason="No reason provided"):
    """Add a role to a member"""
    stats_manager.log_command("addrole")
    
    if ctx.author.top_role <= role and not ctx.author.guild_permissions.administrator:
        return await ctx.send("You cannot assign a role that is higher than or equal to your highest role.")
    
    try:
        # Add the role
        await member.add_roles(role, reason=f"{ctx.author}: {reason}")
        
        # Log the action
        await log_action(
            ctx.guild, 
            "Add Role", 
            user=member,
            moderator=ctx.author, 
            reason=f"Added role {role.name}: {reason}"
        )
        
        # Send confirmation
        embed = discord.Embed(
            title="Role Added",
            description=f"Added role {role.mention} to {member.mention}.",
            color=role.color
        )
        embed.add_field(name="Reason", value=reason)
        
        await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to manage roles.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_roles=True)
async def removerole(ctx, member: discord.Member, role: discord.Role, *, reason="No reason provided"):
    """Remove a role from a member"""
    stats_manager.log_command("removerole")
    
    if ctx.author.top_role <= role and not ctx.author.guild_permissions.administrator:
        return await ctx.send("You cannot remove a role that is higher than or equal to your highest role.")
    
    if role not in member.roles:
        return await ctx.send(f"{member.mention} does not have the role {role.mention}.")
    
    try:
        # Remove the role
        await member.remove_roles(role, reason=f"{ctx.author}: {reason}")
        
        # Log the action
        await log_action(
            ctx.guild, 
            "Remove Role", 
            user=member,
            moderator=ctx.author, 
            reason=f"Removed role {role.name}: {reason}"
        )
        
        # Send confirmation
        embed = discord.Embed(
            title="Role Removed",
            description=f"Removed role {role.mention} from {member.mention}.",
            color=role.color
        )
        embed.add_field(name="Reason", value=reason)
        
        await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("I don't have permission to manage roles.")
    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")

@bot.command()
@commands.guild_only()
@commands.has_permissions(manage_roles=True)
async def createrolemenu(ctx, channel: Optional[discord.TextChannel] = None, *, title_and_description):
    """Create a role menu in a channel
    Format: !createrolemenu #channel Title |(</h1>
</body>
</html>
