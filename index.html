<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>import os
import re
import json
import random
import asyncio
import logging
import datetime
import time
from typing import Optional, Union, List, Dict, Any
from collections import Counter, defaultdict

import discord
from discord.ext import commands, tasks
from dotenv import load_dotenv
import aiosqlite
import pandas as pd
import matplotlib.pyplot as plt
from PIL import Image
import pytesseract
import spacy
import pytz

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("bot.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("ModeratorBot")

# Load environment variables
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
DEFAULT_PREFIX = os.getenv('DEFAULT_PREFIX', '!')

# Load NLP model for content analysis
try:
    nlp = spacy.load("en_core_web_sm")
except:
    logger.warning("NLP model not found. Installing...")
    os.system("python -m spacy download en_core_web_sm")
    nlp = spacy.load("en_core_web_sm")

# Intents setup - the bot needs all privileged intents for full functionality
intents = discord.Intents.all()

class ModeratorBot(commands.Bot):
    def __init__(self):
        super().__init__(
            command_prefix=self.get_prefix,
            intents=intents,
            case_insensitive=True,
            help_command=None  # Custom help command will be implemented
        )
        
        # Bot configuration
        self.db_path = "moderator_bot.db"
        self.auto_mod_config = {}
        self.custom_commands = {}
        self.muted_users = {}
        self.warn_counts = {}
        self.user_analytics = defaultdict(lambda: {
            "messages": 0,
            "commands": 0,
            "reactions": 0,
            "voice_time": 0,
            "last_active": None
        })
        self.raid_detection = {
            "new_joins": [],
            "raid_mode": False,
            "threshold": 5,  # Number of joins within timeframe to trigger raid mode
            "timeframe": 10,  # Timeframe in seconds
        }
        
        # Event tracking system
        self.events = {}
        
        # Activity analytics
        self.message_activity = defaultdict(int)
        self.hourly_activity = defaultdict(int)
        
        # Temporary voice channels
        self.temp_voice_channels = set()
        
        # Lock for database operations
        self.db_lock = asyncio.Lock()
        
        # Add event listeners for various Discord events
        self.setup_event_listeners()
        
        # Register background tasks
        self.start_background_tasks()

    async def setup_hook(self):
        """Set up the bot's database and load extensions."""
        await self.setup_database()
        await self.load_config()
        await self.load_extensions()
        logger.info("Bot setup complete!")

    async def setup_database(self):
        """Initialize the database and create necessary tables."""
        async with self.db_lock:
            async with aiosqlite.connect(self.db_path) as db:
                # Server configurations
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS server_config (
                        guild_id INTEGER PRIMARY KEY,
                        prefix TEXT DEFAULT '!',
                        mute_role_id INTEGER,
                        mod_log_channel_id INTEGER,
                        welcome_channel_id INTEGER,
                        welcome_message TEXT,
                        farewell_message TEXT,
                        auto_role_id INTEGER
                    )
                ''')
                
                # Auto-moderation settings
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS auto_mod_config (
                        guild_id INTEGER PRIMARY KEY,
                        banned_words TEXT,
                        spam_threshold INTEGER DEFAULT 5,
                        spam_timeframe INTEGER DEFAULT 5,
                        image_scanning BOOLEAN DEFAULT 0,
                        max_mentions INTEGER DEFAULT 5,
                        link_whitelist TEXT,
                        caps_percentage INTEGER DEFAULT 70,
                        auto_mod_enabled BOOLEAN DEFAULT 1
                    )
                ''')
                
                # User warnings and infractions
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS infractions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        guild_id INTEGER,
                        user_id INTEGER,
                        moderator_id INTEGER,
                        infraction_type TEXT,
                        reason TEXT,
                        timestamp INTEGER,
                        active BOOLEAN DEFAULT 1
                    )
                ''')
                
                # Custom commands
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS custom_commands (
                        guild_id INTEGER,
                        command_name TEXT,
                        response TEXT,
                        created_by INTEGER,
                        created_at INTEGER,
                        uses INTEGER DEFAULT 0,
                        PRIMARY KEY (guild_id, command_name)
                    )
                ''')
                
                # User analytics
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS user_analytics (
                        guild_id INTEGER,
                        user_id INTEGER,
                        messages INTEGER DEFAULT 0,
                        commands INTEGER DEFAULT 0,
                        reactions INTEGER DEFAULT 0,
                        voice_time INTEGER DEFAULT 0,
                        last_active INTEGER,
                        PRIMARY KEY (guild_id, user_id)
                    )
                ''')
                
                # Scheduled events
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS events (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        guild_id INTEGER,
                        name TEXT,
                        description TEXT,
                        channel_id INTEGER,
                        creator_id INTEGER,
                        start_time INTEGER,
                        end_time INTEGER,
                        reminder_sent BOOLEAN DEFAULT 0
                    )
                ''')
                
                # Temporary mutes
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS temp_mutes (
                        guild_id INTEGER,
                        user_id INTEGER,
                        end_time INTEGER,
                        PRIMARY KEY (guild_id, user_id)
                    )
                ''')
                
                # Level system
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS levels (
                        guild_id INTEGER,
                        user_id INTEGER,
                        xp INTEGER DEFAULT 0,
                        level INTEGER DEFAULT 0,
                        PRIMARY KEY (guild_id, user_id)
                    )
                ''')
                
                # Role management
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS role_menu (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        guild_id INTEGER,
                        channel_id INTEGER,
                        message_id INTEGER,
                        roles TEXT
                    )
                ''')
                
                await db.commit()
                logger.info("Database setup complete")

    async def load_config(self):
        """Load configurations from the database."""
        async with self.db_lock:
            async with aiosqlite.connect(self.db_path) as db:
                # Load auto-mod configurations
                async for row in db.execute("SELECT guild_id, banned_words, spam_threshold, auto_mod_enabled FROM auto_mod_config"):
                    guild_id, banned_words, spam_threshold, enabled = row
                    self.auto_mod_config[guild_id] = {
                        "banned_words": json.loads(banned_words) if banned_words else [],
                        "spam_threshold": spam_threshold,
                        "enabled": bool(enabled)
                    }
                
                # Load custom commands
                async for row in db.execute("SELECT guild_id, command_name, response FROM custom_commands"):
                    guild_id, cmd_name, response = row
                    if guild_id not in self.custom_commands:
                        self.custom_commands[guild_id] = {}
                    self.custom_commands[guild_id][cmd_name] = response
                
                # Load temporary mutes
                async for row in db.execute("SELECT guild_id, user_id, end_time FROM temp_mutes"):
                    guild_id, user_id, end_time = row
                    if guild_id not in self.muted_users:
                        self.muted_users[guild_id] = {}
                    self.muted_users[guild_id][user_id] = end_time
                
                # Load events
                async for row in db.execute("SELECT id, guild_id, name, channel_id, start_time, end_time FROM events WHERE end_time > ?", 
                                          (int(time.time()),)):
                    event_id, guild_id, name, channel_id, start_time, end_time = row
                    if guild_id not in self.events:
                        self.events[guild_id] = {}
                    self.events[guild_id][event_id] = {
                        "name": name,
                        "channel_id": channel_id,
                        "start_time": start_time,
                        "end_time": end_time
                    }

    async def load_extensions(self):
        """Load all command extensions."""
        # This would normally load external cogs files. For this example, we'll define all commands in this file.
        logger.info("Loading extensions...")
        # Example: await self.load_extension("cogs.moderation")
        
    async def get_prefix(self, message):
        """Get the command prefix for a specific guild."""
        default = DEFAULT_PREFIX
        
        if not message.guild:
            return commands.when_mentioned_or(default)(self, message)
            
        guild_id = message.guild.id
        
        async with self.db_lock:
            async with aiosqlite.connect(self.db_path) as db:
                cursor = await db.execute(
                    "SELECT prefix FROM server_config WHERE guild_id = ?", 
                    (guild_id,)
                )
                result = await cursor.fetchone()
                
        if result:
            prefix = result[0]
        else:
            prefix = default
            
        return commands.when_mentioned_or(prefix)(self, message)

    def setup_event_listeners(self):
        """Set up event listeners for Discord events."""
        @self.event
        async def on_ready():
            logger.info(f"Bot is ready! Logged in as {self.user.name} (ID: {self.user.id})")
            logger.info(f"Connected to {len(self.guilds)} guilds")
            
            # Update bot status with server count
            await self.change_presence(
                activity=discord.Activity(
                    type=discord.ActivityType.watching, 
                    name=f"{len(self.guilds)} servers | !help"
                )
            )
            
            # Start background tasks
            self.check_temp_mutes.start()
            self.check_scheduled_events.start()
            self.backup_database.start()
            self.update_analytics.start()

        @self.event
        async def on_message(message):
            # Ignore messages from bots
            if message.author.bot:
                return
                
            # Process commands first
            ctx = await self.get_context(message)
            if ctx.valid:
                # Log command usage in analytics
                if message.guild:
                    self.user_analytics[f"{message.guild.id}:{message.author.id}"]["commands"] += 1
                    self.user_analytics[f"{message.guild.id}:{message.author.id}"]["last_active"] = int(time.time())
                
                await self.invoke(ctx)
                return
                
            # Skip auto-moderation checks for DMs
            if not message.guild:
                return
                
            # Update message activity
            guild_id = message.guild.id
            self.message_activity[guild_id] += 1
            hour = datetime.datetime.now().hour
            self.hourly_activity[f"{guild_id}:{hour}"] += 1
            
            # Update user analytics
            user_key = f"{guild_id}:{message.author.id}"
            self.user_analytics[user_key]["messages"] += 1
            self.user_analytics[user_key]["last_active"] = int(time.time())
            
            # Check for custom commands
            if guild_id in self.custom_commands:
                content = message.content.lower()
                for cmd, response in self.custom_commands[guild_id].items():
                    if content == cmd or content.startswith(f"{cmd} "):
                        await message.channel.send(response)
                        
                        # Update usage count
                        async with self.db_lock:
                            async with aiosqlite.connect(self.db_path) as db:
                                await db.execute(
                                    "UPDATE custom_commands SET uses = uses + 1 WHERE guild_id = ? AND command_name = ?",
                                    (guild_id, cmd)
                                )
                                await db.commit()
                        return
            
            # Auto-moderation checks
            await self.run_auto_moderation(message)

        @self.event
        async def on_member_join(member):
            guild_id = member.guild.id
            
            # Raid detection
            current_time = time.time()
            self.raid_detection["new_joins"].append(current_time)
            
            # Remove old joins outside timeframe
            self.raid_detection["new_joins"] = [
                t for t in self.raid_detection["new_joins"] 
                if current_time - t <= self.raid_detection["timeframe"]
            ]
            
            # Check if we've hit the raid threshold
            if len(self.raid_detection["new_joins"]) >= self.raid_detection["threshold"]:
                if not self.raid_detection["raid_mode"]:
                    self.raid_detection["raid_mode"] = True
                    
                    # Get mod log channel
                    mod_log = await self.get_mod_log_channel(member.guild)
                    if mod_log:
                        embed = discord.Embed(
                            title="âš ï¸ RAID MODE ACTIVATED",
                            description=f"Detected {len(self.raid_detection['new_joins'])} joins in {self.raid_detection['timeframe']} seconds!",
                            color=discord.Color.red()
                        )
                        await mod_log.send(embed=embed)
            
            # Auto-role assignment
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    cursor = await db.execute(
                        "SELECT auto_role_id, welcome_channel_id, welcome_message FROM server_config WHERE guild_id = ?",
                        (guild_id,)
                    )
                    result = await cursor.fetchone()
                    
            if result:
                auto_role_id, welcome_channel_id, welcome_message = result
                
                # Assign auto-role if configured and not in raid mode
                if auto_role_id and not self.raid_detection["raid_mode"]:
                    try:
                        role = member.guild.get_role(auto_role_id)
                        if role:
                            await member.add_roles(role)
                    except discord.HTTPException:
                        pass
                
                # Send welcome message
                if welcome_channel_id and welcome_message:
                    channel = member.guild.get_channel(welcome_channel_id)
                    if channel:
                        # Format welcome message with placeholders
                        formatted_message = welcome_message.replace("{user}", member.mention)
                        formatted_message = formatted_message.replace("{server}", member.guild.name)
                        formatted_message = formatted_message.replace("{count}", str(member.guild.member_count))
                        
                        await channel.send(formatted_message)

        @self.event
        async def on_member_remove(member):
            guild_id = member.guild.id
            
            # Send farewell message if configured
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    cursor = await db.execute(
                        "SELECT welcome_channel_id, farewell_message FROM server_config WHERE guild_id = ?",
                        (guild_id,)
                    )
                    result = await cursor.fetchone()
            
            if result:
                channel_id, farewell_message = result
                if channel_id and farewell_message:
                    channel = member.guild.get_channel(channel_id)
                    if channel:
                        # Format farewell message with placeholders
                        formatted_message = farewell_message.replace("{user}", str(member))
                        formatted_message = formatted_message.replace("{server}", member.guild.name)
                        formatted_message = formatted_message.replace("{count}", str(member.guild.member_count))
                        
                        await channel.send(formatted_message)

        @self.event
        async def on_guild_join(guild):
            logger.info(f"Joined new guild: {guild.name} (ID: {guild.id})")
            
            # Create default configuration
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    await db.execute(
                        "INSERT OR IGNORE INTO server_config (guild_id, prefix) VALUES (?, ?)",
                        (guild.id, DEFAULT_PREFIX)
                    )
                    await db.execute(
                        "INSERT OR IGNORE INTO auto_mod_config (guild_id, banned_words) VALUES (?, ?)",
                        (guild.id, json.dumps([]))
                    )
                    await db.commit()
                    
            # Find a suitable channel to send welcome message
            system_channel = guild.system_channel or next((ch for ch in guild.text_channels if ch.permissions_for(guild.me).send_messages), None)
            
            if system_channel:
                embed = discord.Embed(
                    title=f"Thanks for adding {self.user.name}!",
                    description=f"To get started, use `{DEFAULT_PREFIX}help` to see all commands.\n"
                               f"Admins can use `{DEFAULT_PREFIX}setup` to configure the bot.",
                    color=discord.Color.blue()
                )
                embed.add_field(
                    name="Support",
                    value="If you need help, join our support server or visit our documentation.",
                    inline=False
                )
                embed.set_footer(text=f"Bot Version 1.0.0")
                
                await system_channel.send(embed=embed)

        @self.event
        async def on_guild_remove(guild):
            logger.info(f"Left guild: {guild.name} (ID: {guild.id})")
            # We could clean up guild data here, but often it's better to keep it in case they re-add the bot

        @self.event
        async def on_command_error(ctx, error):
            # Handle various command errors
            if isinstance(error, commands.CommandNotFound):
                # Check if it might be a custom command with a typo
                if ctx.guild:
                    guild_id = ctx.guild.id
                    if guild_id in self.custom_commands:
                        # Find similar commands using basic string similarity
                        cmd_name = ctx.message.content.split()[0][len(ctx.prefix):]
                        similar = self.find_similar_command(cmd_name, list(self.custom_commands[guild_id].keys()))
                        if similar:
                            await ctx.send(f"Command not found. Did you mean `{similar}`?")
                            return
                            
            elif isinstance(error, commands.MissingPermissions):
                await ctx.send(f"âŒ You don't have the required permissions to use this command.")
                
            elif isinstance(error, commands.BotMissingPermissions):
                await ctx.send(f"âŒ I don't have the required permissions to execute this command.")
                
            elif isinstance(error, commands.MissingRequiredArgument):
                await ctx.send(f"âŒ Missing required argument: `{error.param.name}`. Use `{ctx.prefix}help {ctx.command.name}` for proper usage.")
                
            elif isinstance(error, commands.BadArgument):
                await ctx.send(f"âŒ Invalid argument provided. Use `{ctx.prefix}help {ctx.command.name}` for proper usage.")
                
            else:
                # Log unexpected errors
                logger.error(f"Command error in {ctx.command}: {error}")
                await ctx.send("âŒ An unexpected error occurred. Please try again later.")

        @self.event
        async def on_reaction_add(reaction, user):
            # Ignore bot reactions
            if user.bot:
                return
                
            message = reaction.message
            if not message.guild:
                return
                
            # Update user analytics
            guild_id = message.guild.id
            user_key = f"{guild_id}:{user.id}"
            self.user_analytics[user_key]["reactions"] += 1
            self.user_analytics[user_key]["last_active"] = int(time.time())
            
            # Check for role menu reactions
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    cursor = await db.execute(
                        "SELECT roles FROM role_menu WHERE guild_id = ? AND channel_id = ? AND message_id = ?",
                        (guild_id, message.channel.id, message.id)
                    )
                    result = await cursor.fetchone()
                    
            if result:
                roles_data = json.loads(result[0])
                emoji_str = str(reaction.emoji)
                
                if emoji_str in roles_data:
                    role_id = roles_data[emoji_str]
                    role = message.guild.get_role(role_id)
                    
                    if role:
                        try:
                            member = await message.guild.fetch_member(user.id)
                            await member.add_roles(role)
                            
                            # DM the user about the role assignment
                            try:
                                await user.send(f"You've been given the **{role.name}** role in **{message.guild.name}**!")
                            except:
                                pass  # Can't DM the user
                                
                        except discord.HTTPException as e:
                            logger.error(f"Error assigning role: {e}")

        @self.event
        async def on_reaction_remove(reaction, user):
            # Ignore bot reactions
            if user.bot:
                return
                
            message = reaction.message
            if not message.guild:
                return
                
            # Check for role menu reactions
            guild_id = message.guild.id
            
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    cursor = await db.execute(
                        "SELECT roles FROM role_menu WHERE guild_id = ? AND channel_id = ? AND message_id = ?",
                        (guild_id, message.channel.id, message.id)
                    )
                    result = await cursor.fetchone()
                    
            if result:
                roles_data = json.loads(result[0])
                emoji_str = str(reaction.emoji)
                
                if emoji_str in roles_data:
                    role_id = roles_data[emoji_str]
                    role = message.guild.get_role(role_id)
                    
                    if role:
                        try:
                            member = await message.guild.fetch_member(user.id)
                            await member.remove_roles(role)
                        except discord.HTTPException as e:
                            logger.error(f"Error removing role: {e}")

        @self.event
        async def on_voice_state_update(member, before, after):
            # Ignore bot voice state updates
            if member.bot:
                return
                
            if not member.guild:
                return
                
            guild_id = member.guild.id
            user_key = f"{guild_id}:{member.id}"
            
            # Track voice time for analytics
            if before.channel is None and after.channel is not None:
                # User joined a voice channel
                self.user_analytics[user_key]["voice_join_time"] = time.time()
                self.user_analytics[user_key]["last_active"] = int(time.time())
                
            elif before.channel is not None and after.channel is None:
                # User left a voice channel
                if "voice_join_time" in self.user_analytics[user_key]:
                    join_time = self.user_analytics[user_key]["voice_join_time"]
                    voice_time = time.time() - join_time
                    self.user_analytics[user_key]["voice_time"] += voice_time
                    del self.user_analytics[user_key]["voice_join_time"]
                    
            # Handle temporary voice channels
            if after.channel and after.channel.id in self.temp_voice_channels:
                # Get the user's name for the new channel
                channel_name = f"{member.display_name}'s Channel"
                
                try:
                    # Create a new voice channel
                    new_channel = await after.channel.category.create_voice_channel(
                        name=channel_name,
                        bitrate=after.channel.bitrate,
                        user_limit=5  # Default limit of 5
                    )
                    
                    # Move the user to the new channel
                    await member.move_to(new_channel)
                    
                    # Create a task to monitor the channel and delete it when empty
                    self.loop.create_task(self.monitor_temp_channel(new_channel))
                    
                except discord.HTTPException as e:
                    logger.error(f"Error creating temporary voice channel: {e}")

    def start_background_tasks(self):
        """Register all background tasks."""
        @tasks.loop(seconds=60)
        async def check_temp_mutes():
            """Check for temporary mutes that have expired and unmute users."""
            current_time = time.time()
            guilds_to_check = list(self.muted_users.keys())
            
            for guild_id in guilds_to_check:
                users_to_unmute = []
                
                for user_id, end_time in self.muted_users[guild_id].items():
                    if current_time >= end_time:
                        users_to_unmute.append(user_id)
                
                if users_to_unmute:
                    guild = self.get_guild(guild_id)
                    if not guild:
                        continue
                        
                    # Get mute role ID
                    async with self.db_lock:
                        async with aiosqlite.connect(self.db_path) as db:
                            cursor = await db.execute(
                                "SELECT mute_role_id FROM server_config WHERE guild_id = ?",
                                (guild_id,)
                            )
                            result = await cursor.fetchone()
                    
                    if not result or not result[0]:
                        continue
                        
                    mute_role = guild.get_role(result[0])
                    if not mute_role:
                        continue
                    
                    # Unmute users
                    for user_id in users_to_unmute:
                        member = guild.get_member(user_id)
                        if member and mute_role in member.roles:
                            try:
                                await member.remove_roles(mute_role, reason="Temporary mute expired")
                                
                                # Log to mod channel
                                mod_log = await self.get_mod_log_channel(guild)
                                if mod_log:
                                    embed = discord.Embed(
                                        title="Member Unmuted",
                                        description=f"{member.mention} has been automatically unmuted (temporary mute expired).",
                                        color=discord.Color.green()
                                    )
                                    await mod_log.send(embed=embed)
                                    
                                # Remove from database
                                async with self.db_lock:
                                    async with aiosqlite.connect(self.db_path) as db:
                                        await db.execute(
                                            "DELETE FROM temp_mutes WHERE guild_id = ? AND user_id = ?",
                                            (guild_id, user_id)
                                        )
                                        await db.commit()
                                
                                # Remove from memory
                                del self.muted_users[guild_id][user_id]
                                
                            except discord.HTTPException as e:
                                logger.error(f"Error unmuting user {user_id}: {e}")

        @tasks.loop(seconds=60)
        async def check_scheduled_events():
            """Check for scheduled events that need notifications or have ended."""
            current_time = time.time()
            
            # Make a copy to avoid modifying during iteration
            events_copy = {g: {e: d.copy() for e, d in events.items()} 
                          for g, events in self.events.items()}
            
            for guild_id, guild_events in events_copy.items():
                guild = self.get_guild(guild_id)
                if not guild:
                    continue
                    
                for event_id, event_data in guild_events.items():
                    # Check if event is about to start (within 15 minutes)
                    if event_data["start_time"] - current_time <= 900 and event_data["start_time"] > current_time:
                        # Send reminder if not already sent
                        async with self.db_lock:
                            async with aiosqlite.connect(self.db_path) as db:
                                cursor = await db.execute(
                                    "SELECT reminder_sent FROM events WHERE id = ?",
                                    (event_id,)
                                )
                                result = await cursor.fetchone()
                                
                                if result and not result[0]:
                                    # Send reminder
                                    channel = guild.get_channel(event_data["channel_id"])
                                    if channel:
                                        start_time_str = datetime.datetime.fromtimestamp(
                                            event_data["start_time"], 
                                            tz=pytz.UTC
                                        ).strftime("%H:%M UTC")
                                        
                                        await channel.send(
                                            f"ðŸ“… Reminder: Event **{event_data['name']}** starts in {int((event_data['start_time'] - current_time) / 60)} minutes! "
                                            f"(at {start_time_str})"
                                        )
                                        
                                        # Mark reminder as sent
                                        await db.execute(
                                            "UPDATE events SET reminder_sent = 1 WHERE id = ?",
                                            (event_id,)
                                        )
                                        await db.commit()
                    
                    # Check if event has ended
                    if current_time >= event_data["end_time"]:
                        # Remove from memory
                        if guild_id in self.events and event_id in self.events[guild_id]:
                            del self.events[guild_id][event_id]
                            
                            # Send event ended message
                            channel = guild.get_channel(event_data["channel_id"])
                            if channel:
                                await channel.send(f"ðŸ“… Event **{event_data['name']}** has ended!")
                                
                            # Remove from database
                            async with self.db_lock:
                                async with aiosqlite.connect(self.db_path) as db:
                                    await db.execute(
                                        "DELETE FROM events WHERE id = ?",
                                        (event_id,)
                                    )
                                    await db.commit()

        @tasks.loop(hours=24)
        async def backup_database():
            """Create daily backups of the database."""
            backup_dir = "backups"
            if not os.path.exists(backup_dir):
                os.makedirs(backup_dir)
                
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = os.path.join(backup_dir, f"moderator_bot_backup_{timestamp}.db")
            
            # Create a copy of the database
            async with self.db_lock:
                try:
                    # Close connection to allow file copy
                    async with aiosqlite.connect(self.db_path) as db:
                        await db.execute("VACUUM")
                        await db.commit()
                    
                    # Copy the file
                    import shutil
                    shutil.copy2(self.db_path, backup_path)
                    
                    logger.info(f"Database backup created: {backup_path}")
                    
                    # Remove old backups (keep last 7)
                    backups = sorted([
                        os.path.join(backup_dir, f) 
                        for f in os.listdir(backup_dir)
                        if f.startswith("moderator_bot_backup_")
                    ])
                    
                    if len(backups) > 7:
                        for old_backup in backups[:-7]:
                            os.remove(old_backup)
                            logger.info(f"Removed old backup: {old_backup}")
                            
                except Exception as e:
                    logger.error(f"Error creating database backup: {e}")

        @tasks.loop(minutes=30)
        async def update_analytics():
            """Periodically save analytics data to the database."""
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    # Update user analytics
                    for key, data in self.user_analytics.items():
                        if ":" not in key:
                            continue
                            
                        guild_id, user_id = map(int, key.split(":"))
                        
                        # Skip if there's no activity to update
                        if not data["messages"] and not data["commands"] and not data["reactions"] and not data["voice_time"]:
                            continue
                            
                        await db.execute(
                            """
                            INSERT INTO user_analytics 
                                (guild_id, user_id, messages, commands, reactions, voice_time, last_active) 
                            VALUES (?, ?, ?, ?, ?, ?, ?)
                            ON CONFLICT(guild_id, user_id) DO UPDATE SET
                                messages = messages + ?,
                                commands = commands + ?,
                                reactions = reactions + ?,
                                voice_time = voice_time + ?,
                                last_active = ?
                            """,
                            (
                                guild_id, user_id, 
                                data["messages"], data["commands"], data["reactions"], data["voice_time"], data["last_active"],
                                data["messages"], data["commands"], data["reactions"], data["voice_time"], data["last_active"]
                            )
                        )
                        
                        # Reset counters
                        data["messages"] = 0
                        data["commands"] = 0
                        data["reactions"] = 0
                        data["voice_time"] = 0
                        
                    await db.commit()
                    logger.info("Analytics data saved to database")

        self.check_temp_mutes = check_temp_mutes
        self.check_scheduled_events = check_scheduled_events
        self.backup_database = backup_database
        self.update_analytics = update_analytics

    async def run_auto_moderation(self, message):
        """Run auto-moderation checks on a message."""
        if not message.guild:
            return
            
        guild_id = message.guild.id
        
        # Skip if auto-mod is disabled for this guild
        if guild_id in self.auto_mod_config and not self.auto_mod_config[guild_id].get("enabled", True):
            return
            
        # Get auto-mod config
        async with self.db_lock:
            async with aiosqlite.connect(self.db_path) as db:
                cursor = await db.execute(
                    """
                    SELECT 
                        banned_words, spam_threshold, spam_timeframe, 
                        image_scanning, max_mentions, link_whitelist, 
                        caps_percentage, auto_mod_enabled
                    FROM auto_mod_config 
                    WHERE guild_id = ?
                    """,
                    (guild_id,)
                )
                result = await cursor.fetchone()
                
        if not result or not result[7]:  # auto_mod_enabled check
            return
            
        banned_words, spam_threshold, spam_timeframe, image_scanning, max_mentions, link_whitelist, caps_percentage, _ = result
        
        # Convert JSON strings to Python objects
        banned_words = json.loads(banned_words) if banned_words else []
        link_whitelist = json.loads(link_whitelist) if link_whitelist else []
        
        content = message.content.lower()
        reason = None
        action = None
        
        # Check for banned words
        if banned_words:
            for word in banned_words:
                if re.search(r'\b' + re.escape(word.lower()) + r'\b', content):
                    reason = f"Message contained banned word: {word}"
                    action = "delete"
                    break
        
        # Check for excessive caps
        if not reason and caps_percentage > 0:
            if len(message.content) >= 8:  # Only check longer messages
                uppercase_count = sum(1 for c in message.content if c.isupper())
                total_chars = sum(1 for c in message.content if c.isalpha())
                
                if total_chars > 0 and (uppercase_count / total_chars * 100) > caps_percentage:
                    reason = f"Message contained excessive caps ({int(uppercase_count / total_chars * 100)}%)"
                    action = "delete"
        
        # Check for spam
        if not reason and spam_threshold > 0:
            # Get recent messages from the user in this channel
            messages = [msg async for msg in message.channel.history(
                limit=spam_threshold + 1, 
                after=datetime.datetime.now() - datetime.timedelta(seconds=spam_timeframe)
            ) if msg.author == message.author]
            
            if len(messages) >= spam_threshold:
                # Check for content similarity
                content_set = set()
                for msg in messages:
                    content_set.add(msg.content)
                    
                if len(content_set) <= 2:  # If the user is repeating the same message
                    reason = f"Message spam detected (sent {len(messages)} similar messages in {spam_timeframe} seconds)"
                    action = "warn"
        
        # Check for excessive mentions
        if not reason and max_mentions > 0:
            mention_count = len(message.mentions) + len(message.role_mentions)
            if mention_count > max_mentions:
                reason = f"Message contained excessive mentions ({mention_count})"
                action = "delete"
        
        # Check for non-whitelisted links
        if not reason and link_whitelist:
            # Extract URLs from message
            urls = re.findall(r'(https?://\S+)', message.content)
            
            if urls:
                for url in urls:
                    # Check if the URL's domain is in the whitelist
                    domain_match = re.search(r'https?://(?:www\.)?([^/]+)', url)
                    if domain_match:
                        domain = domain_match.group(1)
                        if domain not in link_whitelist:
                            reason = f"Message contained link to non-whitelisted domain: {domain}"
                            action = "delete"
                            break
        
        # Check for image content if enabled
        if not reason and image_scanning and message.attachments:
            for attachment in message.attachments:
                if attachment.content_type and "image" in attachment.content_type:
                    # Here we'd normally implement image scanning for inappropriate content
                    # For this example, we'll just log that image scanning would happen
                    logger.info(f"Image would be scanned for inappropriate content: {attachment.url}")
        
        # Take action if violation detected
        if reason:
            # Get mod log channel
            mod_log = await self.get_mod_log_channel(message.guild)
            
            if action == "delete":
                try:
                    await message.delete()
                    
                    # Notify user
                    try:
                        await message.author.send(
                            f"Your message in {message.guild.name} was removed by auto-moderation.\n"
                            f"Reason: {reason}"
                        )
                    except:
                        pass  # Can't DM the user
                        
                    # Log to mod channel
                    if mod_log:
                        embed = discord.Embed(
                            title="Auto-Moderation: Message Deleted",
                            description=f"User: {message.author.mention} ({message.author.id})\nChannel: {message.channel.mention}\nReason: {reason}",
                            color=discord.Color.orange()
                        )
                        embed.add_field(name="Message Content", value=message.content[:1024] if message.content else "(No text content)")
                        await mod_log.send(embed=embed)
                        
                except discord.HTTPException:
                    logger.error(f"Failed to delete message in auto-moderation")
                    
            elif action == "warn":
                # Add warning to the user
                await self.add_infraction(
                    guild=message.guild,
                    user=message.author,
                    moderator=message.guild.me,
                    infraction_type="warn",
                    reason=reason
                )
                
                # Log to mod channel
                if mod_log:
                    embed = discord.Embed(
                        title="Auto-Moderation: User Warned",
                        description=f"User: {message.author.mention} ({message.author.id})\nChannel: {message.channel.mention}\nReason: {reason}",
                        color=discord.Color.yellow()
                    )
                    await mod_log.send(embed=embed)

    async def add_infraction(self, guild, user, moderator, infraction_type, reason):
        """Add an infraction to a user's record."""
        guild_id = guild.id
        user_id = user.id
        moderator_id = moderator.id
        timestamp = int(time.time())
        
        async with self.db_lock:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    """
                    INSERT INTO infractions 
                        (guild_id, user_id, moderator_id, infraction_type, reason, timestamp) 
                    VALUES (?, ?, ?, ?, ?, ?)
                    """,
                    (guild_id, user_id, moderator_id, infraction_type, reason, timestamp)
                )
                await db.commit()
        
        # Update warning count for escalation
        if guild_id not in self.warn_counts:
            self.warn_counts[guild_id] = {}
            
        if user_id not in self.warn_counts[guild_id]:
            self.warn_counts[guild_id][user_id] = 0
            
        if infraction_type == "warn":
            self.warn_counts[guild_id][user_id] += 1
            
            # Check if we need to escalate punishment based on warning count
            warn_count = self.warn_counts[guild_id][user_id]
            
            if warn_count == 3:
                # Mute for 1 hour after 3 warnings
                await self.mute_user(guild, user, guild.me, 3600, "Automatic mute after 3 warnings")
                
            elif warn_count == 5:
                # Kick after 5 warnings
                try:
                    await guild.kick(user, reason="Automatic kick after 5 warnings")
                    
                    # Log the action
                    mod_log = await self.get_mod_log_channel(guild)
                    if mod_log:
                        embed = discord.Embed(
                            title="Member Kicked",
                            description=f"{user.mention} was automatically kicked after receiving 5 warnings.",
                            color=discord.Color.red()
                        )
                        await mod_log.send(embed=embed)
                        
                except discord.HTTPException as e:
                    logger.error(f"Failed to kick user after 5 warnings: {e}")
                    
            elif warn_count >= 7:
                # Ban after 7 warnings
                try:
                    await guild.ban(user, reason="Automatic ban after 7 warnings", delete_message_days=1)
                    
                    # Log the action
                    mod_log = await self.get_mod_log_channel(guild)
                    if mod_log:
                        embed = discord.Embed(
                            title="Member Banned",
                            description=f"{user} was automatically banned after receiving 7 warnings.",
                            color=discord.Color.dark_red()
                        )
                        await mod_log.send(embed=embed)
                        
                except discord.HTTPException as e:
                    logger.error(f"Failed to ban user after 7 warnings: {e}")

    async def mute_user(self, guild, user, moderator, duration, reason):
        """Mute a user for a specified duration."""
        guild_id = guild.id
        user_id = user.id
        
        # Get mute role
        async with self.db_lock:
            async with aiosqlite.connect(self.db_path) as db:
                cursor = await db.execute(
                    "SELECT mute_role_id FROM server_config WHERE guild_id = ?",
                    (guild_id,)
                )
                result = await cursor.fetchone()
                
        if not result or not result[0]:
            # Create a mute role if it doesn't exist
            try:
                mute_role = await guild.create_role(name="Muted", reason="Auto-created mute role")
                
                # Set permissions for all channels
                for channel in guild.channels:
                    try:
                        if isinstance(channel, discord.TextChannel):
                            await channel.set_permissions(mute_role, send_messages=False, add_reactions=False)
                        elif isinstance(channel, discord.VoiceChannel):
                            await channel.set_permissions(mute_role, speak=False)
                    except:
                        pass  # Skip channels where we don't have permission
                        
                # Save the role ID
                async with self.db_lock:
                    async with aiosqlite.connect(self.db_path) as db:
                        await db.execute(
                            """
                            UPDATE server_config 
                            SET mute_role_id = ? 
                            WHERE guild_id = ?
                            """,
                            (mute_role.id, guild_id)
                        )
                        await db.commit()
                        
            except discord.HTTPException as e:
                logger.error(f"Error creating mute role: {e}")
                return False
        else:
            mute_role = guild.get_role(result[0])
            if not mute_role:
                logger.error(f"Mute role not found")
                return False
                
        try:
            # Add the mute role
            await user.add_roles(mute_role, reason=reason)
            
            # Record the temporary mute
            end_time = time.time() + duration
            
            if guild_id not in self.muted_users:
                self.muted_users[guild_id] = {}
                
            self.muted_users[guild_id][user_id] = end_time
            
            # Save to database
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    await db.execute(
                        """
                        INSERT OR REPLACE INTO temp_mutes
                            (guild_id, user_id, end_time)
                        VALUES (?, ?, ?)
                        """,
                        (guild_id, user_id, end_time)
                    )
                    await db.commit()
                    
            # Log the mute
            mod_log = await self.get_mod_log_channel(guild)
            if mod_log:
                duration_str = self.format_duration(duration)
                embed = discord.Embed(
                    title="Member Muted",
                    description=f"{user.mention} has been muted for {duration_str}.",
                    color=discord.Color.orange()
                )
                embed.add_field(name="Reason", value=reason)
                embed.add_field(name="Moderator", value=moderator.mention)
                await mod_log.send(embed=embed)
                
            # Add to infractions
            await self.add_infraction(
                guild=guild,
                user=user,
                moderator=moderator,
                infraction_type="mute",
                reason=f"{reason} (Duration: {duration_str})"
            )
            
            return True
            
        except discord.HTTPException as e:
            logger.error(f"Error muting user: {e}")
            return False

    async def get_mod_log_channel(self, guild):
        """Get the mod log channel for a guild."""
        guild_id = guild.id
        
        async with self.db_lock:
            async with aiosqlite.connect(self.db_path) as db:
                cursor = await db.execute(
                    "SELECT mod_log_channel_id FROM server_config WHERE guild_id = ?",
                    (guild_id,)
                )
                result = await cursor.fetchone()
                
        if result and result[0]:
            return guild.get_channel(result[0])
        return None

    def format_duration(self, seconds):
        """Format a duration in seconds to a human-readable string."""
        if seconds < 60:
            return f"{seconds} second{'s' if seconds != 1 else ''}"
        elif seconds < 3600:
            minutes = seconds // 60
            return f"{minutes} minute{'s' if minutes != 1 else ''}"
        elif seconds < 86400:
            hours = seconds // 3600
            return f"{hours} hour{'s' if hours != 1 else ''}"
        else:
            days = seconds // 86400
            return f"{days} day{'s' if days != 1 else ''}"

    def find_similar_command(self, cmd, cmd_list, threshold=0.7):
        """Find a similar command using string similarity."""
        best_match = None
        best_ratio = 0
        
        for existing_cmd in cmd_list:
            # Simple string similarity
            ratio = sum(a == b for a, b in zip(cmd, existing_cmd)) / max(len(cmd), len(existing_cmd))
            
            if ratio > threshold and ratio > best_ratio:
                best_match = existing_cmd
                best_ratio = ratio
                
        return best_match

    async def monitor_temp_channel(self, channel, check_interval=10):
        """Monitor a temporary voice channel and delete it when empty."""
        try:
            while True:
                await asyncio.sleep(check_interval)
                
                # Check if the channel still exists
                try:
                    c = self.get_channel(channel.id)
                    if not c:
                        return
                        
                    # Delete if empty
                    if len(c.members) == 0:
                        await c.delete(reason="Temporary voice channel is empty")
                        return
                except:
                    return  # Channel was deleted
                    
        except asyncio.CancelledError:
            pass

    async def generate_server_stats(self, guild):
        """Generate statistics for a server."""
        # Member stats
        total_members = guild.member_count
        online_members = sum(1 for m in guild.members if m.status != discord.Status.offline)
        bot_count = sum(1 for m in guild.members if m.bot)
        
        # Channel stats
        text_channels = len(guild.text_channels)
        voice_channels = len(guild.voice_channels)
        categories = len(guild.categories)
        
        # Role stats
        role_count = len(guild.roles) - 1  # Exclude @everyone
        
        # Message activity
        guild_id = guild.id
        message_count = self.message_activity.get(guild_id, 0)
        
        # Get hourly activity data
        hour_data = {}
        for key, count in self.hourly_activity.items():
            if key.startswith(f"{guild_id}:"):
                hour = int(key.split(":")[1])
                hour_data[hour] = count
                
        # Create figure for hourly activity
        plt.figure(figsize=(10, 5))
        hours = list(range(24))
        activity = [hour_data.get(h, 0) for h in hours]
        plt.bar(hours, activity)
        plt.title("Message Activity by Hour")
        plt.xlabel("Hour (UTC)")
        plt.ylabel("Message Count")
        plt.xticks(hours[::2])
        plt.grid(axis='y', alpha=0.3)
        
        # Save figure to bytes buffer
        import io
        buf = io.BytesIO()
        plt.savefig(buf, format='png')
        buf.seek(0)
        
        # Get top users from database
        async with self.db_lock:
            async with aiosqlite.connect(self.db_path) as db:
                cursor = await db.execute(
                    """
                    SELECT user_id, messages, commands, reactions, voice_time
                    FROM user_analytics
                    WHERE guild_id = ?
                    ORDER BY messages DESC
                    LIMIT 5
                    """,
                    (guild_id,)
                )
                top_users = await cursor.fetchall()
                
        # Combine all stats
        stats = {
            "members": {
                "total": total_members,
                "online": online_members,
                "bots": bot_count,
                "humans": total_members - bot_count
            },
            "channels": {
                "text": text_channels,
                "voice": voice_channels,
                "categories": categories,
                "total": text_channels + voice_channels
            },
            "roles": role_count,
            "messages": message_count,
            "hourly_activity": hour_data,
            "top_users": [
                {
                    "id": user_id,
                    "messages": messages,
                    "commands": commands,
                    "reactions": reactions,
                    "voice_time": voice_time
                }
                for user_id, messages, commands, reactions, voice_time in top_users
            ]
        }
        
        return stats, buf

    # Define all the bot commands
    async def setup_commands(self):
        """Set up all commands for the bot."""
        
        # Help command
        @self.command(name="help")
        async def help_command(ctx, command=None):
            """Show help for commands."""
            prefix = ctx.prefix
            
            if command:
                cmd = self.get_command(command)
                if cmd:
                    embed = discord.Embed(
                        title=f"Help: {prefix}{cmd.name}",
                        description=cmd.help or "No description available.",
                        color=discord.Color.blue()
                    )
                    
                    # Add usage if available
                    usage = getattr(cmd, "usage", None)
                    if usage:
                        embed.add_field(name="Usage", value=f"{prefix}{cmd.name} {usage}", inline=False)
                    
                    # Add aliases if available
                    if cmd.aliases:
                        embed.add_field(name="Aliases", value=", ".join([f"{prefix}{alias}" for alias in cmd.aliases]), inline=False)
                        
                    await ctx.send(embed=embed)
                else:
                    await ctx.send(f"âŒ Command `{command}` not found.")
            else:
                # Group commands by category
                categories = {
                    "Moderation": [],
                    "Auto-Moderation": [],
                    "Configuration": [],
                    "Utility": [],
                    "Fun": [],
                    "Custom Commands": [],
                    "Analytics": [],
                    "Events": [],
                    "Miscellaneous": []
                }
                
                # Assign commands to categories
                for cmd in self.commands:
                    category = getattr(cmd, "category", "Miscellaneous")
                    if category in categories:
                        categories[category].append(cmd)
                    else:
                        categories["Miscellaneous"].append(cmd)
                        
                embed = discord.Embed(
                    title=f"{self.user.name} Help",
                    description=f"Use `{prefix}help <command>` for more information on a command.",
                    color=discord.Color.blue()
                )
                
                # Add fields for each category
                for category, cmds in categories.items():
                    if cmds:
                        cmd_list = ", ".join([f"`{prefix}{cmd.name}`" for cmd in sorted(cmds, key=lambda x: x.name)])
                        embed.add_field(name=category, value=cmd_list, inline=False)
                        
                embed.set_footer(text=f"Bot Version 1.0.0 | Servers: {len(self.guilds)}")
                await ctx.send(embed=embed)

        # Setup command
        @self.command(name="setup")
        @commands.has_permissions(administrator=True)
        async def setup_command(ctx):
            """Set up the bot for your server."""
            await ctx.send("ðŸ”§ Setup wizard starting! Please check your DMs.")
            
            try:
                # Send initial DM
                await ctx.author.send(f"Welcome to the {self.user.name} setup wizard! Let's configure the bot for your server.")
                
                # Get mod log channel
                await ctx.author.send("First, let's set up a **mod log channel**. Please enter the name of the channel to use (or type 'create' to create a new one):")
                
                def check(m):
                    return m.author == ctx.author and m.guild is None
                    
                try:
                    response = await self.wait_for('message', check=check, timeout=60)
                    
                    mod_log_channel = None
                    if response.content.lower() == 'create':
                        # Create new channel
                        try:
                            overwrites = {
                                ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),
                                ctx.guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
                            }
                            mod_log_channel = await ctx.guild.create_text_channel('mod-log', overwrites=overwrites)
                            await ctx.author.send(f"âœ… Created new channel: {mod_log_channel.mention}")
                        except:
                            await ctx.author.send("âŒ Failed to create channel. Please make sure I have the `Manage Channels` permission.")
                    else:
                        # Find existing channel
                        channel_name = response.content.lower().strip('#')
                        mod_log_channel = discord.utils.get(ctx.guild.text_channels, name=channel_name)
                        
                        if not mod_log_channel:
                            await ctx.author.send("âŒ Channel not found. Using default mod-log channel.")
                            
                    # Save mod log channel
                    if mod_log_channel:
                        async with self.db_lock:
                            async with aiosqlite.connect(self.db_path) as db:
                                await db.execute(
                                    """
                                    INSERT INTO server_config (guild_id, mod_log_channel_id) 
                                    VALUES (?, ?)
                                    ON CONFLICT(guild_id) DO UPDATE SET
                                    mod_log_channel_id = ?
                                    """,
                                    (ctx.guild.id, mod_log_channel.id, mod_log_channel.id)
                                )
                                await db.commit()
                        
                    # Get mute role
                    await ctx.author.send("Next, let's set up a **mute role**. Please enter the name of the role to use (or type 'create' to create a new one):")
                    
                    response = await self.wait_for('message', check=check, timeout=60)
                    
                    mute_role = None
                    if response.content.lower() == 'create':
                        # Create new role
                        try:
                            mute_role = await ctx.guild.create_role(name="Muted", reason="Setup wizard")
                            
                            # Set permissions for all channels
                            for channel in ctx.guild.channels:
                                try:
                                    if isinstance(channel, discord.TextChannel):
                                        await channel.set_permissions(mute_role, send_messages=False, add_reactions=False)
                                    elif isinstance(channel, discord.VoiceChannel):
                                        await channel.set_permissions(mute_role, speak=False)
                                except:
                                    pass  # Skip channels where we don't have permission
                                    
                            await ctx.author.send(f"âœ… Created new role: {mute_role.name}")
                        except:
                            await ctx.author.send("âŒ Failed to create role. Please make sure I have the `Manage Roles` permission.")
                    else:
                        # Find existing role
                        role_name = response.content
                        mute_role = discord.utils.get(ctx.guild.roles, name=role_name)
                        
                        if not mute_role:
                            await ctx.author.send("âŒ Role not found. Using default Muted role.")
                            
                    # Save mute role
                    if mute_role:
                        async with self.db_lock:
                            async with aiosqlite.connect(self.db_path) as db:
                                await db.execute(
                                    """
                                    UPDATE server_config 
                                    SET mute_role_id = ? 
                                    WHERE guild_id = ?
                                    """,
                                    (mute_role.id, ctx.guild.id)
                                )
                                await db.commit()
                                
                    # Set up welcome channel and message
                    await ctx.author.send("Would you like to set up welcome messages? (yes/no)")
                    
                    response = await self.wait_for('message', check=check, timeout=60)
                    
                    if response.content.lower() in ['yes', 'y']:
                        await ctx.author.send("Please enter the name of the welcome channel:")
                        
                        response = await self.wait_for('message', check=check, timeout=60)
                        channel_name = response.content.lower().strip('#')
                        welcome_channel = discord.utils.get(ctx.guild.text_channels, name=channel_name)
                        
                        if welcome_channel:
                            await ctx.author.send(f"Using {welcome_channel.mention} for welcome messages.")
                            
                            await ctx.author.send(
                                "Please enter the welcome message. You can use these placeholders:\n"
                                "`{user}` - Mentions the new user\n"
                                "`{server}` - The server name\n"
                                "`{count}` - The current member count"
                            )
                            
                            response = await self.wait_for('message', check=check, timeout=120)
                            welcome_message = response.content
                            
                            # Ask for farewell message
                            await ctx.author.send(
                                "Please enter the farewell message (when users leave). You can use the same placeholders:\n"
                                "`{user}` - The username of the person who left\n"
                                "`{server}` - The server name\n"
                                "`{count}` - The current member count"
                            )
                            
                            response = await self.wait_for('message', check=check, timeout=120)
                            farewell_message = response.content
                            
                            # Save welcome configuration
                            async with self.db_lock:
                                async with aiosqlite.connect(self.db_path) as db:
                                    await db.execute(
                                        """
                                        UPDATE server_config 
                                        SET welcome_channel_id = ?, welcome_message = ?, farewell_message = ? 
                                        WHERE guild_id = ?
                                        """,
                                        (welcome_channel.id, welcome_message, farewell_message, ctx.guild.id)
                                    )
                                    await db.commit()
                                    
                            await ctx.author.send("âœ… Welcome messages configured!")
                        else:
                            await ctx.author.send("âŒ Channel not found. Skipping welcome message setup.")
                            
                    # Set up auto-role
                    await ctx.author.send("Would you like to set up an auto-role for new members? (yes/no)")
                    
                    response = await self.wait_for('message', check=check, timeout=60)
                    
                    if response.content.lower() in ['yes', 'y']:
                        await ctx.author.send("Please enter the name of the role to give to new members:")
                        
                        response = await self.wait_for('message', check=check, timeout=60)
                        role_name = response.content
                        auto_role = discord.utils.get(ctx.guild.roles, name=role_name)
                        
                        if auto_role:
                            # Save auto-role
                            async with self.db_lock:
                                async with aiosqlite.connect(self.db_path) as db:
                                    await db.execute(
                                        """
                                        UPDATE server_config 
                                        SET auto_role_id = ? 
                                        WHERE guild_id = ?
                                        """,
                                        (auto_role.id, ctx.guild.id)
                                    )
                                    await db.commit()
                                    
                            await ctx.author.send(f"âœ… Auto-role set to: {auto_role.name}")
                        else:
                            await ctx.author.send("âŒ Role not found. Skipping auto-role setup.")
                            
                    # Set up banned words
                    await ctx.author.send("Would you like to configure banned words for auto-moderation? (yes/no)")
                    
                    response = await self.wait_for('message', check=check, timeout=60)
                    
                    if response.content.lower() in ['yes', 'y']:
                        await ctx.author.send("Please enter the words to ban, separated by commas:")
                        
                        response = await self.wait_for('message', check=check, timeout=120)
                        banned_words = [word.strip().lower() for word in response.content.split(',')]
                        
                        # Save banned words
                        async with self.db_lock:
                            async with aiosqlite.connect(self.db_path) as db:
                                await db.execute(
                                    """
                                    UPDATE auto_mod_config 
                                    SET banned_words = ? 
                                    WHERE guild_id = ?
                                    """,
                                    (json.dumps(banned_words), ctx.guild.id)
                                )
                                await db.commit()
                                
                        await ctx.author.send(f"âœ… Banned {len(banned_words)} words.")
                        
                        # Update in-memory config
                        if ctx.guild.id not in self.auto_mod_config:
                            self.auto_mod_config[ctx.guild.id] = {}
                        self.auto_mod_config[ctx.guild.id]["banned_words"] = banned_words
                        
                    # Finish setup
                    await ctx.author.send(
                        "ðŸŽ‰ Setup complete! The bot is now configured for your server.\n\n"
                        f"Use `{ctx.prefix}help` to see all available commands."
                    )
                    
                except asyncio.TimeoutError:
                    await ctx.author.send("âŒ Setup timed out. Please run the command again when you're ready.")
                    
            except discord.Forbidden:
                await ctx.send("âŒ I couldn't send you a DM. Please enable DMs from server members and try again.")

        # Moderation commands
        @self.command(name="ban")
        @commands.has_permissions(ban_members=True)
        @commands.bot_has_permissions(ban_members=True)
        async def ban_command(ctx, member: discord.Member, delete_days: int = 1, *, reason="No reason provided"):
            """Ban a member from the server."""
            if member == ctx.author:
                return await ctx.send("âŒ You cannot ban yourself.")
                
            if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
                return await ctx.send("âŒ You cannot ban someone with a higher or equal role.")
                
            if member.top_role >= ctx.guild.me.top_role:
                return await ctx.send("âŒ I cannot ban someone with a higher or equal role to me.")
                
            # Log the action
            mod_log = await self.get_mod_log_channel(ctx.guild)
            
            try:
                # Notify the user
                try:
                    embed = discord.Embed(
                        title=f"You've been banned from {ctx.guild.name}",
                        description=f"**Reason:** {reason}",
                        color=discord.Color.red()
                    )
                    await member.send(embed=embed)
                except:
                    pass  # Can't DM the user
                    
                # Ban the user
                await ctx.guild.ban(member, reason=f"{reason} - By {ctx.author}", delete_message_days=delete_days)
                
                # Confirm in channel
                await ctx.send(f"âœ… **{member}** has been banned | {reason}")
                
                # Log to mod channel
                if mod_log:
                    embed = discord.Embed(
                        title="Member Banned",
                        description=f"{member.mention} has been banned.",
                        color=discord.Color.red()
                    )
                    embed.add_field(name="Reason", value=reason)
                    embed.add_field(name="Moderator", value=ctx.author.mention)
                    embed.add_field(name="Deleted Messages", value=f"Last {delete_days} day(s)")
                    embed.set_thumbnail(url=member.display_avatar.url)
                    await mod_log.send(embed=embed)
                    
                # Add to infractions
                await self.add_infraction(
                    guild=ctx.guild,
                    user=member,
                    moderator=ctx.author,
                    infraction_type="ban",
                    reason=reason
                )
                
            except discord.HTTPException as e:
                await ctx.send(f"âŒ Failed to ban user: {e}")

        @self.command(name="unban")
        @commands.has_permissions(ban_members=True)
        @commands.bot_has_permissions(ban_members=True)
        async def unban_command(ctx, user_id: int, *, reason="No reason provided"):
            """Unban a user by ID."""
            try:
                # Get ban entry
                ban_entry = None
                async for entry in ctx.guild.bans():
                    if entry.user.id == user_id:
                        ban_entry = entry
                        break
                        
                if not ban_entry:
                    return await ctx.send(f"âŒ User with ID {user_id} is not banned.")
                    
                # Unban the user
                await ctx.guild.unban(ban_entry.user, reason=f"{reason} - By {ctx.author}")
                
                # Confirm in channel
                await ctx.send(f"âœ… **{ban_entry.user}** has been unbanned | {reason}")
                
                # Log to mod channel
                mod_log = await self.get_mod_log_channel(ctx.guild)
                if mod_log:
                    embed = discord.Embed(
                        title="Member Unbanned",
                        description=f"{ban_entry.user} has been unbanned.",
                        color=discord.Color.green()
                    )
                    embed.add_field(name="Reason", value=reason)
                    embed.add_field(name="Moderator", value=ctx.author.mention)
                    await mod_log.send(embed=embed)
                    
                # Add to infractions
                await self.add_infraction(
                    guild=ctx.guild,
                    user=ban_entry.user,
                    moderator=ctx.author,
                    infraction_type="unban",
                    reason=reason
                )
                
            except discord.HTTPException as e:
                await ctx.send(f"âŒ Failed to unban user: {e}")

        @self.command(name="kick")
        @commands.has_permissions(kick_members=True)
        @commands.bot_has_permissions(kick_members=True)
        async def kick_command(ctx, member: discord.Member, *, reason="No reason provided"):
            """Kick a member from the server."""
            if member == ctx.author:
                return await ctx.send("âŒ You cannot kick yourself.")
                
            if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
                return await ctx.send("âŒ You cannot kick someone with a higher or equal role.")
                
            if member.top_role >= ctx.guild.me.top_role:
                return await ctx.send("âŒ I cannot kick someone with a higher or equal role to me.")
                
            try:
                # Notify the user
                try:
                    embed = discord.Embed(
                        title=f"You've been kicked from {ctx.guild.name}",
                        description=f"**Reason:** {reason}",
                        color=discord.Color.orange()
                    )
                    await member.send(embed=embed)
                except:
                    pass  # Can't DM the user
                    
                # Kick the user
                await ctx.guild.kick(member, reason=f"{reason} - By {ctx.author}")
                
                # Confirm in channel
                await ctx.send(f"âœ… **{member}** has been kicked | {reason}")
                
                # Log to mod channel
                mod_log = await self.get_mod_log_channel(ctx.guild)
                if mod_log:
                    embed = discord.Embed(
                        title="Member Kicked",
                        description=f"{member.mention} has been kicked.",
                        color=discord.Color.orange()
                    )
                    embed.add_field(name="Reason", value=reason)
                    embed.add_field(name="Moderator", value=ctx.author.mention)
                    embed.set_thumbnail(url=member.display_avatar.url)
                    await mod_log.send(embed=embed)
                    
                # Add to infractions
                await self.add_infraction(
                    guild=ctx.guild,
                    user=member,
                    moderator=ctx.author,
                    infraction_type="kick",
                    reason=reason
                )
                
            except discord.HTTPException as e:
                await ctx.send(f"âŒ Failed to kick user: {e}")

        @self.command(name="mute")
        @commands.has_permissions(manage_roles=True)
        @commands.bot_has_permissions(manage_roles=True)
        async def mute_command(ctx, member: discord.Member, duration: str = "1h", *, reason="No reason provided"):
            """Mute a member for a specified duration.
            
            Duration format: 1m, 1h, 1d (minutes, hours, days)
            """
            if member == ctx.author:
                return await ctx.send("âŒ You cannot mute yourself.")
                
            if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
                return await ctx.send("âŒ You cannot mute someone with a higher or equal role.")
                
            if member.top_role >= ctx.guild.me.top_role:
                return await ctx.send("âŒ I cannot mute someone with a higher or equal role to me.")
                
            # Parse duration
            duration_seconds = 0
            if duration.endswith("m"):
                duration_seconds = int(duration[:-1]) * 60
            elif duration.endswith("h"):
                duration_seconds = int(duration[:-1]) * 3600
            elif duration.endswith("d"):
                duration_seconds = int(duration[:-1]) * 86400
            else:
                try:
                    duration_seconds = int(duration) * 60  # Default to minutes
                except ValueError:
                    return await ctx.send("âŒ Invalid duration format. Use 1m, 1h, 1d format.")
                    
            # Mute the user
            success = await self.mute_user(
                guild=ctx.guild,
                user=member,
                moderator=ctx.author,
                duration=duration_seconds,
                reason=reason
            )
            
            if success:
                duration_str = self.format_duration(duration_seconds)
                await ctx.send(f"âœ… **{member}** has been muted for {duration_str} | {reason}")
            else:
                await ctx.send("âŒ Failed to mute user. Make sure the mute role is configured properly.")

        @self.command(name="unmute")
        @commands.has_permissions(manage_roles=True)
        @commands.bot_has_permissions(manage_roles=True)
        async def unmute_command(ctx, member: discord.Member, *, reason="No reason provided"):
            """Unmute a muted member."""
            # Get mute role
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    cursor = await db.execute(
                        "SELECT mute_role_id FROM server_config WHERE guild_id = ?",
                        (ctx.guild.id,)
                    )
                    result = await cursor.fetchone()
                    
            if not result or not result[0]:
                return await ctx.send("âŒ Mute role not configured. Use `!setup` to configure it.")
                
            mute_role = ctx.guild.get_role(result[0])
            if not mute_role:
                return await ctx.send("âŒ Mute role not found. It may have been deleted.")
                
            if mute_role not in member.roles:
                return await ctx.send("âŒ This member is not muted.")
                
            try:
                # Remove mute role
                await member.remove_roles(mute_role, reason=f"{reason} - By {ctx.author}")
                
                # Confirm in channel
                await ctx.send(f"âœ… **{member}** has been unmuted | {reason}")
                
                # Log to mod channel
                mod_log = await self.get_mod_log_channel(ctx.guild)
                if mod_log:
                    embed = discord.Embed(
                        title="Member Unmuted",
                        description=f"{member.mention} has been unmuted.",
                        color=discord.Color.green()
                    )
                    embed.add_field(name="Reason", value=reason)
                    embed.add_field(name="Moderator", value=ctx.author.mention)
                    await mod_log.send(embed=embed)
                    
                # Add to infractions
                await self.add_infraction(
                    guild=ctx.guild,
                    user=member,
                    moderator=ctx.author,
                    infraction_type="unmute",
                    reason=reason
                )
                
                # Remove from temporary mutes if applicable
                guild_id = ctx.guild.id
                user_id = member.id
                
                if guild_id in self.muted_users and user_id in self.muted_users[guild_id]:
                    del self.muted_users[guild_id][user_id]
                    
                    async with self.db_lock:
                        async with aiosqlite.connect(self.db_path) as db:
                            await db.execute(
                                "DELETE FROM temp_mutes WHERE guild_id = ? AND user_id = ?",
                                (guild_id, user_id)
                            )
                            await db.commit()
                            
            except discord.HTTPException as e:
                await ctx.send(f"âŒ Failed to unmute user: {e}")

        @self.command(name="warn")
        @commands.has_permissions(manage_messages=True)
        async def warn_command(ctx, member: discord.Member, *, reason="No reason provided"):
            """Warn a member."""
            if member == ctx.author:
                return await ctx.send("âŒ You cannot warn yourself.")
                
            if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
                return await ctx.send("âŒ You cannot warn someone with a higher or equal role.")
                
            # Add warning
            await self.add_infraction(
                guild=ctx.guild,
                user=member,
                moderator=ctx.author,
                infraction_type="warn",
                reason=reason
            )
            
            # Notify the user
            try:
                embed = discord.Embed(
                    title=f"You've been warned in {ctx.guild.name}",
                    description=f"**Reason:** {reason}",
                    color=discord.Color.yellow()
                )
                await member.send(embed=embed)
            except:
                pass  # Can't DM the user
                
            # Confirm in channel
            await ctx.send(f"âœ… **{member}** has been warned | {reason}")
            
            # Log to mod channel
            mod_log = await self.get_mod_log_channel(ctx.guild)
            if mod_log:
                embed = discord.Embed(
                    title="Member Warned",
                    description=f"{member.mention} has been warned.",
                    color=discord.Color.yellow()
                )
                embed.add_field(name="Reason", value=reason)
                embed.add_field(name="Moderator", value=ctx.author.mention)
                await mod_log.send(embed=embed)
                
            # Check for escalation
            guild_id = ctx.guild.id
            user_id = member.id
            
            if guild_id not in self.warn_counts:
                self.warn_counts[guild_id] = {}
                
            if user_id not in self.warn_counts[guild_id]:
                self.warn_counts[guild_id][user_id] = 0
                
            self.warn_counts[guild_id][user_id] += 1
            warn_count = self.warn_counts[guild_id][user_id]
            
            # Send message about warning count
            await ctx.send(f"âš ï¸ This is warning #{warn_count} for {member.mention}.")
            
            # Apply automated punishment if threshold reached
            if warn_count == 3:
                await ctx.send(f"âš ï¸ {member.mention} has reached 3 warnings. Auto-muting for 1 hour.")
                await self.mute_user(ctx.guild, member, ctx.guild.me, 3600, "Automatic mute after 3 warnings")
                
            elif warn_count == 5:
                await ctx.send(f"âš ï¸ {member.mention} has reached 5 warnings. Auto-kicking from server.")
                try:
                    await ctx.guild.kick(member, reason="Automatic kick after 5 warnings")
                except discord.HTTPException:
                    await ctx.send("âŒ Failed to auto-kick user due to insufficient permissions.")
                    
            elif warn_count >= 7:
                await ctx.send(f"âš ï¸ {member.mention} has reached 7 warnings. Auto-banning from server.")
                try:
                    await ctx.guild.ban(member, reason="Automatic ban after 7 warnings", delete_message_days=1)
                except discord.HTTPException:
                    await ctx.send("âŒ Failed to auto-ban user due to insufficient permissions.")

        @self.command(name="infractions", aliases=["warns", "warnings"])
        @commands.has_permissions(manage_messages=True)
        async def infractions_command(ctx, member: discord.Member):
            """View a member's infractions."""
            guild_id = ctx.guild.id
            user_id = member.id
            
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    cursor = await db.execute(
                        """
                        SELECT id, infraction_type, reason, moderator_id, timestamp
                        FROM infractions
                        WHERE guild_id = ? AND user_id = ?
                        ORDER BY timestamp DESC
                        """,
                        (guild_id, user_id)
                    )
                    infractions = await cursor.fetchall()
                    
            if not infractions:
                return await ctx.send(f"âœ… **{member}** has no infractions on record.")
                
            # Count infractions by type
            infraction_counts = Counter(i[1] for i in infractions)
            
            embed = discord.Embed(
                title=f"Infractions for {member}",
                description=f"Total: {len(infractions)} infractions",
                color=discord.Color.blue()
            )
            
            # Add summary
            summary = "\n".join([f"**{count}** {infraction_type}" for infraction_type, count in infraction_counts.items()])
            embed.add_field(name="Summary", value=summary, inline=False)
            
            # Add recent infractions
            recent = []
            for i, (infr_id, infr_type, reason, mod_id, timestamp) in enumerate(infractions[:5]):
                moderator = ctx.guild.get_member(mod_id) or f"Unknown Moderator ({mod_id})"
                time_str = datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M")
                recent.append(f"**{i+1}.** [{infr_id}] **{infr_type}** by {moderator}\n{time_str} - {reason}")
                
            if recent:
                embed.add_field(name="Recent Infractions", value="\n\n".join(recent), inline=False)
                
            embed.set_footer(text=f"Use {ctx.prefix}infraction <id> for details on a specific infraction")
            await ctx.send(embed=embed)

        @self.command(name="infraction")
        @commands.has_permissions(manage_messages=True)
        async def infraction_command(ctx, infraction_id: int):
            """View details of a specific infraction."""
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    cursor = await db.execute(
                        """
                        SELECT user_id, moderator_id, infraction_type, reason, timestamp, active
                        FROM infractions
                        WHERE id = ? AND guild_id = ?
                        """,
                        (infraction_id, ctx.guild.id)
                    )
                    result = await cursor.fetchone()
                    
            if not result:
                return await ctx.send(f"âŒ Infraction with ID {infraction_id} not found.")
                
            user_id, moderator_id, infraction_type, reason, timestamp, active = result
            
            user = ctx.guild.get_member(user_id) or f"Unknown User ({user_id})"
            moderator = ctx.guild.get_member(moderator_id) or f"Unknown Moderator ({moderator_id})"
            time_str = datetime.datetime.fromtimestamp(timestamp).strftime("%Y-%m-%d %H:%M:%S")
            
            embed = discord.Embed(
                title=f"Infraction #{infraction_id}",
                color=discord.Color.blue()
            )
            
            embed.add_field(name="User", value=str(user), inline=True)
            embed.add_field(name="Moderator", value=str(moderator), inline=True)
            embed.add_field(name="Type", value=infraction_type, inline=True)
            embed.add_field(name="Time", value=time_str, inline=True)
            embed.add_field(name="Active", value="Yes" if active else "No", inline=True)
            embed.add_field(name="Reason", value=reason, inline=False)
            
            await ctx.send(embed=embed)

        @self.command(name="clearinfraction", aliases=["delinfraction", "removeinfraction"])
        @commands.has_permissions(administrator=True)
        async def clearinfraction_command(ctx, infraction_id: int):
            """Remove an infraction from a user's record."""
            async with self.db_lock:
                async with aiosqlite.connect(self.db_path) as db:
                    cursor = await db.execute(
                        """
                        SELECT user_id, infraction_type
                        FROM infractions
                        WHERE id = ? AND guild_id = ?
                        """,
                        (infraction_id, ctx.guild.id)
                    )
                    result = await cursor.fetchone()
                    
                    if not result:
                        return await ctx.send(f"âŒ Infraction with ID {infraction_id} not found.")
                        
                    user_id, infraction_type = result
                    
                    # Delete the infraction
                    await db.execute(
                        "DELETE FROM infractions WHERE id = ?",
                        (infraction_id,)
                    )
                    await db.commit()
                    
            # Get user
            user = ctx.guild.get_member(user_id) or f"Unknown User ({user_id})"
            
            # Confirm in channel
            await ctx.send(f"âœ… Removed {infraction_type} infraction #{infraction_id} from {user}'s record.")
            
            # Log to mod channel
            mod_log = await self.get_mod_log_channel(ctx.guild)
            if mod_log:
                embed = discord.Embed(
                    title="Infraction Removed",
                    description=f"Infraction #{infraction_id} ({infraction_type}) has been removed from {user}'s record.",
                    color=discord.Color.green()
                )
                embed.add_field(name="Moderator", value=ctx.author.mention)
                await mod_log.send(embed=embed)

        @self.command(name="purge", aliases=["clear"])
        @commands.has_permissions(manage_messages=True)
        @commands.bot_has_permissions(manage_messages=True)
        async def purge_command(ctx, amount: int, member: discord.Member = None):
            """Delete a specified number of messages from a channel."""
            if amount <= 0:
                return await ctx.send("âŒ Please specify a positive number of messages to delete.")
                
            if amount > 100:
                return await ctx.send("âŒ You can only delete up to 100 messages at once.")
                
            try:
                if member:
                    # Delete messages from a specific user
                    def check(message):
                        return message.author == member
                        
                    deleted = await ctx.channel.purge(limit=amount + 1, check=check)
                    # Subtract 1 for the command message
                    await ctx.send(f"âœ… Deleted {len(deleted) - 1} messages from {member}.", delete_after=5)
                else:
                    # Delete messages from anyone
                    deleted = await ctx.channel.purge(limit=amount + 1)
                    # Subtract 1 for the command message
                    await ctx.send(f"âœ… Deleted {len(deleted) - 1} messages.", delete_after=5)
                    
                # Log to mod channel
                mod_log = await self.get_mod_log_channel(ctx.guild)
                if mod_log:
                    embed = discord.Embed(
                        title="Messages Purged",
                        description=f"{len(deleted) - 1} messages were deleted from {ctx.channel.mention}",
                        color=discord.Color.blue()
                    )
                    embed.add_field(name="Moderator", value=ctx.author.mention)
                    if member:
                        embed.add_field(name="Target User", value=member.mention)
                    await mod_log.send(embed=embed)
                    
            except discord.HTTPException as e:
                await ctx.send(f"âŒ Error deleting messages: {e}")

        @self.command(name="lockdown")
        @commands.has_permissions(manage_channels=True)
        @commands.bot_has_permissions(manage_channels=True)
        async def lockdown_command(ctx, channel: discord.TextChannel = None, *, reason="No reason provided"):
            """Prevent users from sending messages in a channel."""
            channel = channel or ctx.channel
            
            try:
                # Lock the channel
                await channel.set_permissions(ctx.guild.default_role, send_messages=False)
                
                await channel.send(f"ðŸ”’ This channel has been locked by {ctx.author.mention}. Reason: {reason}")
                
                # Log to mod channel
                mod_log = await self.get_mod_log_channel(ctx.guild)
                if mod_log:
                    embed = discord.Embed(
                        title="Channel Locked",
                        description=f"{channel.mention} has been locked.",
                        color=discord.Color.red()
                    )
                    embed.add_field(name="Reason", value=reason)
                    embed.add_field(name="Moderator", value=ctx.author.mention)
                    await mod_log.send(embed=embed)
                    
            except discord.HTTPException as e:
                await ctx.send(f"âŒ Error locking channel: {e}")

        @self.command(name="unlock")
        @commands.has_permissions(manage_channels=True)
        @commands.bot_has_permissions(manage_channels=True)
        async def unlock_command(ctx, channel: discord.TextChannel = None):
            """Allow users to send messages in a locked channel."""
            channel = channel or ctx.channel
            
            try:
                # Unlock the channel
                await channel.set_permissions(ctx.guild.default_role, send_messages=None)
                
                await channel.send(f"ðŸ”“ This channel has been unlocked by {ctx.author.mention}.")
                
                # Log to mod channel
                mod_log = await self.get_mod_log_channel(ctx.guild)
                if mod_log:
                    embed = discord.Embed(
                        title="Channel Unlocked",
                        description=f"{ctx.author.mention} unlocked {channel.mention}",
                        color=discord.Color.green(),
                        timestamp=datetime.datetime.utcnow()
                    )
                    embed.set_author(name=ctx.author.name, icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
                    await mod_log.send(embed=embed)
                    
            except Exception as e:
                await ctx.send(f"Failed to unlock the channel: {e}")

            class Moderation(commands.Cog):
                def __init__(self, bot):
                    self.bot = bot

                async def get_mod_log_channel(self, guild):
                    """Get the mod log channel for the guild."""
                    mod_log_id = await self.bot.db.get_mod_log(guild.id)
                    if mod_log_id:
                        return self.bot.get_channel(mod_log_id)
                    return None
                
                @commands.command()
                @commands.has_permissions(manage_channels=True)
                async def lock(self, ctx, channel: discord.TextChannel = None):
                    channel = channel or ctx.channel

                    try:
                        await channel.set_permissions(ctx.guild.default_role, send_messages=False)
                        await channel.send(f"ðŸ”’ This channel has been locked by {ctx.author.mention}.")

                        mod_log = await self.get_mod_log_channel(ctx.guild)
                        if mod_log:
                            embed = discord.Embed(
                                title="Channel Locked",
                                description=f"{ctx.author.mention} locked {channel.mention}",
                                color=discord.Color.red(),
                                timestamp=datetime.datetime.utcnow()
                            )
                            embed.set_author(name=ctx.author.name, icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
                            await mod_log.send(embed=embed)
                            
                    except Exception as e:
                        await ctx.send(f"Failed to lock the channel: {e}")
                
                @commands.command()
                @commands.has_permissions(manage_channels=True)
                async def unlock(self, ctx, channel: discord.TextChannel = None):
                    """Unlock a channel"""
                    channel = channel or ctx.channel
                    
                    try:
                        # Unlock the channel
                        await channel.set_permissions(ctx.guild.default_role, send_messages=None)
                        
                        await channel.send(f"ðŸ”“ This channel has been unlocked by {ctx.author.mention}.")
                        
                        # Log to mod channel
                        mod_log = await self.get_mod_log_channel(ctx.guild)
                        if mod_log:
                            embed = discord.Embed(
                                title="Channel Unlocked",
                                description=f"{ctx.author.mention} unlocked {channel.mention}",
                                color=discord.Color.green(),
                                timestamp=datetime.datetime.utcnow()
                            )
                            embed.set_author(name=ctx.author.name, icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
                            await mod_log.send(embed=embed)
                            
                    except Exception as e:
                        await ctx.send(f"Failed to unlock the channel: {e}")

            def setup(bot):
                bot.add_cog(Moderation(bot))</h1>
</body>
</html>
