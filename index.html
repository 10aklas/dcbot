<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORLEQTOR - Anonymous P2P Chat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        :root {
            --background: #121212;
            --surface: #1e1e1e;
            --primary: #bb86fc;
            --secondary: #03dac6;
            --text: #e0e0e0;
            --text-secondary: #a0a0a0;
            --error: #cf6679;
            --success: #4caf50;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--background);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        header {
            background-color: var(--surface);
            padding: 1rem 2rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        h1 {
            color: var(--primary);
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        .tagline {
            color: var(--text-secondary);
            font-style: italic;
        }
        
        .user-info {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .user-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }
        
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 2rem;
        }
        
        .welcome-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            text-align: center;
        }
        
        .buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
        }
        
        .btn {
            background-color: var(--surface);
            color: var(--text);
            border: 2px solid var(--primary);
            padding: 1rem 2rem;
            border-radius: 8px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 250px;
        }
        
        .btn:hover {
            background-color: var(--primary);
            color: var(--background);
            transform: translateY(-3px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            min-width: auto;
        }
        
        .friend-code-container {
            display: none;
            margin-top: 2rem;
            background-color: var(--surface);
            padding: 1rem 2rem;
            border-radius: 8px;
            text-align: center;
            max-width: 500px;
            width: 100%;
        }
        
        .code-display {
            font-size: 1.5rem;
            color: var(--secondary);
            background-color: rgba(3, 218, 198, 0.1);
            padding: 0.5rem;
            border-radius: 4px;
            margin: 1rem 0;
            user-select: all;
        }
        
        .join-code-container {
            display: none;
            margin-top: 2rem;
            background-color: var(--surface);
            padding: 1rem 2rem;
            border-radius: 8px;
            text-align: center;
            max-width: 500px;
            width: 100%;
        }
        
        .code-input {
            width: 100%;
            padding: 0.5rem 1rem;
            font-size: 1.2rem;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--secondary);
            border-radius: 4px;
            color: var(--text);
            margin: 1rem 0;
        }
        
        .loading-container {
            display: none;
            margin-top: 2rem;
            text-align: center;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 1rem;
        }
        
        .chat-container {
            display: none;
            flex: 1;
            flex-direction: column;
            height: 100%;
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
        }
        
        .chat-header {
            background-color: var(--surface);
            padding: 1rem;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chat-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .partner-name {
            font-weight: bold;
        }
        
        .connection-status {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: var(--error);
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-indicator.connected {
            background-color: var(--success);
        }
        
        .end-chat-btn {
            background-color: var(--error);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .messages {
            flex: 1;
            background-color: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            overflow-y: auto;
            height: 50vh;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .message-container {
            display: flex;
            flex-direction: column;
        }
        
        .message-container.sent {
            align-items: flex-end;
        }
        
        .message-container.received {
            align-items: flex-start;
        }
        
        .message-header {
            font-size: 0.8rem;
            margin-bottom: 2px;
            color: var(--text-secondary);
            padding: 0 0.5rem;
        }
        
        .message {
            max-width: 70%;
            padding: 0.5rem 1rem;
            border-radius: 18px;
            word-wrap: break-word;
        }
        
        .message.received {
            background-color: var(--surface);
            border-bottom-left-radius: 4px;
        }
        
        .message.sent {
            background-color: var(--primary);
            color: var(--background);
            border-bottom-right-radius: 4px;
        }
        
        .system-message {
            text-align: center;
            color: var(--text-secondary);
            margin: 0.5rem 0;
            font-style: italic;
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        .input-area {
            background-color: var(--surface);
            padding: 1rem;
            border-radius: 0 0 8px 8px;
            display: flex;
            gap: 0.5rem;
        }
        
        .message-input {
            flex: 1;
            padding: 0.8rem;
            border-radius: 4px;
            border: none;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text);
            font-size: 1rem;
        }
        
        .message-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(187, 134, 252, 0.3);
        }
        
        .send-btn {
            background-color: var(--secondary);
            color: var(--background);
            border: none;
            border-radius: 4px;
            padding: 0 1.5rem;
            cursor: pointer;
            font-weight: bold;
        }
        
        .send-btn:disabled {
            background-color: rgba(3, 218, 198, 0.3);
            cursor: not-allowed;
        }
        
        .typing-indicator {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
            margin-top: 0.5rem;
            height: 1rem;
        }
        
        .disclaimer {
            margin-top: 2rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-align: center;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .notification {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background-color: var(--surface);
            color: var(--text);
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            animation: slide-in 0.3s ease-out;
        }
        
        .cancel-btn {
            background-color: var(--error);
            margin-top: 1rem;
            width: 100%;
        }
        
        @keyframes slide-in {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        
        @media (max-width: 768px) {
            .buttons {
                flex-direction: column;
            }
            
            main {
                padding: 1rem;
            }
            
            .message {
                max-width: 85%;
            }
            
            .user-info {
                position: static;
                justify-content: center;
                margin-top: 1rem;
            }
        }
    </style>
</head>
<body>
    <div id="notification" class="notification"></div>
    
    <header>
        <h1>ORLEQTOR</h1>
        <p class="tagline">100% Anonymous P2P Chat</p>
        <div id="user-info" class="user-info">
            <div id="user-avatar" class="user-avatar"></div>
            <span id="username">Generating username...</span>
        </div>
    </header>
    
    <main>
        <div class="welcome-screen">
            <h2>Start a secure, anonymous conversation</h2>
            <p>All messages are sent peer-to-peer with no server storage</p>
            
            <div class="buttons">
                <button id="chat-stranger-btn" class="btn">Chat with Stranger</button>
                <button id="chat-friend-btn" class="btn">Chat with Friend</button>
                <button id="join-friend-btn" class="btn">Join with Code</button>
            </div>
            
            <div id="friend-code-container" class="friend-code-container">
                <h3>Share this code with your friend</h3>
                <div id="friend-code" class="code-display">Generating code...</div>
                <p>Your friend can use this code to join your chat room</p>
                <button id="copy-code-btn" class="btn btn-small">Copy Code</button>
                <p id="waiting-message">Waiting for friend to connect...</p>
                <button id="cancel-friend-wait-btn" class="btn btn-small cancel-btn">Cancel</button>
            </div>
            
            <div id="join-code-container" class="join-code-container">
                <h3>Enter your friend's code</h3>
                <input type="text" id="code-input" class="code-input" placeholder="Enter 16-character code" maxlength="16">
                <button id="connect-btn" class="btn btn-small">Connect</button>
                <button id="cancel-join-btn" class="btn btn-small cancel-btn">Cancel</button>
            </div>
            
            <div id="loading-container" class="loading-container">
                <div class="loading-spinner"></div>
                <p id="loading-text" class="loading-text">Waiting for a stranger to chat with...</p>
                <button id="cancel-stranger-search-btn" class="btn btn-small cancel-btn">Cancel Search</button>
            </div>
            
            <p class="disclaimer">
                ORLEQTOR uses peer-to-peer technology to ensure your conversations remain private.
                No messages are stored on any servers. Your randomly generated username changes
                each time you reload the page for complete anonymity.
            </p>
        </div>
        
        <div id="chat-container" class="chat-container">
            <div class="chat-header">
                <div class="chat-info">
                    <span id="status-indicator" class="status-indicator"></span>
                    <span id="partner-name" class="partner-name">Unknown</span>
                    <span id="connection-status" class="connection-status">Connecting...</span>
                </div>
                <button id="end-chat-btn" class="end-chat-btn">End Chat</button>
            </div>
            <div id="messages" class="messages"></div>
            <div class="typing-indicator" id="typing-indicator"></div>
            <div class="input-area">
                <input type="text" id="message-input" class="message-input" placeholder="Type your message..." disabled>
                <button id="send-btn" class="send-btn" disabled>Send</button>
            </div>
        </div>
    </main>
    
    <script>
        // DOM Elements
        const welcomeScreen = document.querySelector('.welcome-screen');
        const chatContainer = document.getElementById('chat-container');
        const chatStrangerBtn = document.getElementById('chat-stranger-btn');
        const chatFriendBtn = document.getElementById('chat-friend-btn');
        const joinFriendBtn = document.getElementById('join-friend-btn');
        const friendCodeContainer = document.getElementById('friend-code-container');
        const friendCode = document.getElementById('friend-code');
        const copyCodeBtn = document.getElementById('copy-code-btn');
        const joinCodeContainer = document.getElementById('join-code-container');
        const codeInput = document.getElementById('code-input');
        const connectBtn = document.getElementById('connect-btn');
        const loadingContainer = document.getElementById('loading-container');
        const loadingText = document.getElementById('loading-text');
        const endChatBtn = document.getElementById('end-chat-btn');
        const messagesContainer = document.getElementById('messages');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const statusIndicator = document.getElementById('status-indicator');
        const connectionStatus = document.getElementById('connection-status');
        const partnerName = document.getElementById('partner-name');
        const waitingMessage = document.getElementById('waiting-message');
        const usernameDisplay = document.getElementById('username');
        const userAvatar = document.getElementById('user-avatar');
        const notification = document.getElementById('notification');
        const typingIndicator = document.getElementById('typing-indicator');
        const cancelStrangerSearchBtn = document.getElementById('cancel-stranger-search-btn');
        const cancelFriendWaitBtn = document.getElementById('cancel-friend-wait-btn');
        const cancelJoinBtn = document.getElementById('cancel-join-btn');
        
        // Global variables
        let peer = null;
        let connection = null;
        let myPeerId = null;
        let myUsername = '';
        let partnerUsername = '';
        let waitingForStranger = false;
        let lookingForStrangerInterval = null;
        let typingTimeout = null;
        let lastTypingSignal = 0;
        let isTyping = false;
        let signalServer = null; // In a real app, this would be a connection to a signaling server
        
        // Generate a random username
        function generateUsername() {
            const adjectives = ["Swift", "Crimson", "Azure", "Golden", "Silver", "Cosmic", "Mystic", "Phantom", "Shadow", "Neon", "Cyber", "Quantum", "Echo", "Nova", "Alpha", "Omega", "Frost", "Phoenix", "Vortex", "Digital", "Crystal", "Onyx", "Sapphire", "Emerald", "Ruby", "Obsidian", "Jade", "Amber", "Coral", "Aqua"];
            const nouns = ["Raven", "Wolf", "Fox", "Hawk", "Eagle", "Tiger", "Dragon", "Lion", "Panther", "Falcon", "Serpent", "Knight", "Ranger", "Hunter", "Ghost", "Specter", "Wraith", "Voyager", "Crusader", "Guardian", "Sentinel", "Nomad", "Wanderer", "Warden", "Pioneer", "Ninja", "Samurai", "Ronin", "Titan", "Oracle"];
            
            const adjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            const number = Math.floor(Math.random() * 1000);
            
            return `${adjective}${noun}${number}`;
        }
        
        // Generate avatar initial and color
        function generateAvatar(username) {
            userAvatar.textContent = username.charAt(0);
            
            // Generate a deterministic color based on username
            const hash = CryptoJS.MD5(username).toString();
            const hue = parseInt(hash.substring(0, 6), 16) % 360;
            userAvatar.style.backgroundColor = `hsl(${hue}, 70%, 60%)`;
        }
        
        // Initialize PeerJS
        function initializePeer() {
            // Create a random ID to ensure anonymity
            const randomId = generateRandomId(32);
            
            // Generate a random username
            myUsername = generateUsername();
            usernameDisplay.textContent = myUsername;
            generateAvatar(myUsername);
            
            // Create peer connection
            peer = new Peer(randomId, {
                debug: 2,
                config: {
                    'iceServers': [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });
            
            peer.on('open', (id) => {
                myPeerId = id;
                console.log('My peer ID is: ' + id);
            });
            
            peer.on('connection', (conn) => {
                if (connection) {
                    // Already connected, reject new connection
                    conn.close();
                    return;
                }
                
                connection = conn;
                setupConnectionListeners();
                
                // If we're waiting for a stranger, we're now connected
                if (waitingForStranger) {
                    waitingForStranger = false;
                    if (lookingForStrangerInterval) {
                        clearInterval(lookingForStrangerInterval);
                        lookingForStrangerInterval = null;
                    }
                    hideElement(loadingContainer);
                }
                
                showChatInterface();
            });
            
            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                showNotification('Connection error: ' + err.message);
                resetChat();
            });
        }
        
        // Generate a random ID with specified length
        function generateRandomId(length) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }
        
        // Generate a 16-character code for friend chat
        function generateFriendCode() {
            return generateRandomId(16);
        }
        
        // Setup connection listeners
        function setupConnectionListeners() {
            connection.on('open', () => {
                // Send my username to partner
                sendMetadata({ type: 'username', username: myUsername });
                
                connectionStatus.textContent = 'Connected';
                statusIndicator.classList.add('connected');
                messageInput.disabled = false;
                sendBtn.disabled = false;
                messageInput.focus();
                
                // Hide waiting message if this was a friend code connection
                hideElement(waitingMessage);
            });
            
            connection.on('data', (data) => {
                if (typeof data === 'object' && data !== null) {
                    handleMetadata(data);
                } else {
                    addMessage(data, 'received');
                }
            });
            
            connection.on('close', () => {
                addSystemMessage('Your chat partner has disconnected.');
                resetChatInterface();
            });
            
            connection.on('error', (err) => {
                console.error('Connection error:', err);
                addSystemMessage('Connection error. Please try again.');
                resetChat();
            });
        }
        
        // Handle metadata messages
        function handleMetadata(data) {
            switch (data.type) {
                case 'username':
                    partnerUsername = data.username;
                    partnerName.textContent = partnerUsername;
                    addSystemMessage(`You are now chatting with ${partnerUsername}`);
                    break;
                case 'typing':
                    if (data.isTyping) {
                        typingIndicator.textContent = `${partnerUsername} is typing...`;
                    } else {
                        typingIndicator.textContent = '';
                    }
                    break;
            }
        }
        
        // Send metadata messages
        function sendMetadata(data) {
            if (connection && connection.open) {
                connection.send(data);
            }
        }
        
        // Add a message to the chat
        function addMessage(text, type) {
            const container = document.createElement('div');
            container.classList.add('message-container', type);
            
            const header = document.createElement('div');
            header.classList.add('message-header');
            header.textContent = type === 'sent' ? myUsername : partnerUsername;
            
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', type);
            messageElement.textContent = text;
            
            container.appendChild(header);
            container.appendChild(messageElement);
            messagesContainer.appendChild(container);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Add a system message
        function addSystemMessage(text) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('system-message');
            messageElement.textContent = text;
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Show notification
        function showNotification(message) {
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }
        
        // Show/hide elements
        function showElement(element) {
            element.style.display = element.tagName === 'DIV' ? 'flex' : 'block';
        }
        
        function hideElement(element) {
            element.style.display = 'none';
        }
        
        // Show the chat interface
        function showChatInterface() {
            hideElement(welcomeScreen);
            showElement(chatContainer);
        }
        
        // Reset the chat interface
        function resetChatInterface() {
            connectionStatus.textContent = 'Disconnected';
            statusIndicator.classList.remove('connected');
            messageInput.disabled = true;
            sendBtn.disabled = true;
            typingIndicator.textContent = '';
        }
        
        // Reset the entire chat and return to welcome screen
        function resetChat() {
            if (connection) {
                connection.close();
                connection = null;
            }
            
            waitingForStranger = false;
            if (lookingForStrangerInterval) {
                clearInterval(lookingForStrangerInterval);
                lookingForStrangerInterval = null;
            }
            
            partnerUsername = '';
            partnerName.textContent = 'Unknown';
            
            // Clear messages
            messagesContainer.innerHTML = '';
            
            // Reset UI
            hideElement(chatContainer);
            showElement(welcomeScreen);
            hideElement(friendCodeContainer);
            hideElement(joinCodeContainer);
            hideElement(loadingContainer);
            resetChatInterface();
        }
        
        // Handle typing indicator
        function handleTyping() {
            if (!isTyping) {
                isTyping = true;
                sendMetadata({ type: 'typing', isTyping: true });
            }
            
            clearTimeout(typingTimeout);
            
            typingTimeout = setTimeout(() => {
                isTyping = false;
                sendMetadata({ type: 'typing', isTyping: false });
            }, 1000);
        }
        
        // Real implementation using a signaling server
        function findStrangerChat() {
            waitingForStranger = true;
            loadingText.textContent = 'Waiting for a stranger to chat with...';
            showElement(loadingContainer);
            
            // In a real app, this would connect to a signaling server that matches peers
            // For now, we'll just wait indefinitely until someone connects directly
            // or until the user cancels the search
            
            // Instead of using setTimeout to simulate finding a peer, we'll wait for a real connection
            console.log('Waiting for a stranger to connect...');
            
            // In a real app, this would register with a signaling server
            // For now, we'll just periodically update the waiting message
            
            let waitSeconds = 0;
            lookingForStrangerInterval = setInterval(() => {
                waitSeconds += 5;
                if (waitSeconds % 30 === 0) {
                    loadingText.textContent = `Been waiting for ${waitSeconds} seconds. Still looking for someone to chat with...`;
                }
            }, 5000);
        }
        
        // Wait for a connection with the given code
        function waitForConnection(code) {
            // In a real app, this would register the code with a signaling server
            waitingMessage.textContent = `Waiting for someone to connect with code: ${code}`;
            showElement(waitingMessage);
            
            // Just wait for an actual connection now
            console.log('Waiting for someone to connect with code:', code);
            
            // A real signaling server would handle matching the code with someone trying to join
        }
        
        // Connect to a peer using a friend code
        function connectWithCode(code) {
            // In a real app, this would look up the peer ID associated with this code
            // from a signaling server
            
            showNotification('Trying to connect with code: ' + code);
            
            // For now, we can't connect without a real signaling server
            // We'll just show a connecting message and wait for a while
            
            addSystemMessage('Trying to connect with your friend...');
            showChatInterface();
            connectionStatus.textContent = 'Connecting...';
            
            // In a real implementation, we would:
            // 1. Send the code to a signaling server
            // 2. Get the peer ID associated with the code
            // 3. Connect to that peer ID
            
            // Since we don't have a real signaling server, we'll show an error after a delay
            setTimeout(() => {
                if (!connection) {
                    addSystemMessage('Could not find anyone with that code. Please try again.');
                    setTimeout(() => {
                        resetChat();
                    }, 3000);
                }
            }, 10000);
        }
        
        // Initialize the application
        function init() {
            initializePeer();
            
            // Event: Chat with stranger
            chatStrangerBtn.addEventListener('click', () => {
                findStrangerChat();
            });
            
            // Event: Chat with friend (create a room)
            chatFriendBtn.addEventListener('click', () => {
                const code = generateFriendCode();
                friendCode.textContent = code;
                showElement(friendCodeContainer);
                hideElement(joinCodeContainer);
                showElement(waitingMessage);
                
                // Wait for someone to connect with this code
                waitForConnection(code);
            });
            
            // Event: Join with code
            joinFriendBtn.addEventListener('click', () => {
                showElement(joinCodeContainer);
                hideElement(friendCodeContainer);
            });
            
            copyCodeBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(generatedRoomCode.textContent)
        .then(() => {
            copyRoomCode.innerHTML = `
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 6L9 17l-5-5"/>
                </svg>
            `;
            
            setTimeout(() => {
                copyRoomCode.innerHTML = `
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                `;
            }, 2000);
        })
        .catch(err => {
            console.error('Could not copy text: ', err);
        });
});

// Initialize app by connecting to signaling server
connectToSignalingServer();

// Add a waiting queue system to ensure users wait for real connections
let waitingForPeer = false;
let waitingInterval = null;
let waitingDots = 0;

// Modify the handleSignalingMessage function to remove the "no_peers_available" case
// and replace it with continuous waiting
function handleSignalingMessage(event) {
    const data = JSON.parse(event.data);
    
    switch(data.type) {
        case 'online_count':
            onlineCount.textContent = `${data.count} user${data.count !== 1 ? 's' : ''} available for P2P chat`;
            break;
            
        case 'offer':
            handleOffer(data);
            break;
            
        case 'answer':
            handleAnswer(data);
            break;
            
        case 'ice_candidate':
            handleIceCandidate(data);
            break;
            
        case 'match_found':
            stopWaitingAnimation();
            searchingAnimation.style.display = 'none';
            addMessage(randomChatMessages, `Found a potential peer! Establishing secure connection...`);
            createPeerConnection('random', data.peerId);
            break;
            
        // Removed the no_peers_available case - the user will always wait for a real peer
            
        case 'room_created':
            currentRoomId = data.roomId;
            generatedRoomCode.textContent = data.connectionCode;
            isConnectedToPrivateRoom = true;
            
            // Set up the peer connection as the host
            createPeerConnection('host', data.roomId);
            break;
            
        case 'peer_joined_room':
            // Someone is joining our room - send them an offer
            currentPartner = data.username;
            addMessage(privateChatMessages, `${currentPartner} is connecting... Establishing secure P2P channel.`);
            createOffer();
            break;
            
        case 'join_success':
            currentRoomId = data.roomId;
            currentPartner = data.hostUsername;
            isJoiningRoom = true;
            
            // Set up the peer connection as the joiner
            createPeerConnection('join', data.roomId);
            break;
            
        case 'room_not_found':
            joiningAnimation.style.display = 'none';
            addMessage(joinChatMessages, 'Room not found. Please check the code and try again.');
            
            // Show back button
            const backBtn = document.createElement('button');
            backBtn.className = 'btn btn-outline';
            backBtn.textContent = 'Back';
            backBtn.style.margin = '10px auto';
            backBtn.style.display = 'block';
            
            backBtn.addEventListener('click', () => {
                joinRoomModal.style.display = 'none';
                document.getElementById('roomCodeInput').value = '';
            });
            
            joinChatMessages.appendChild(backBtn);
            break;
            
        case 'error':
            console.error('Server error:', data.message);
            addMessage(isJoiningRoom ? joinChatMessages : randomChatMessages, 
                `Error: ${data.message}`);
            break;
    }
}

// Add function to start waiting animation with a more persistent message
function startWaitingForUser(type) {
    if (waitingInterval) {
        clearInterval(waitingInterval);
    }
    
    waitingForPeer = true;
    waitingDots = 0;
    
    const messageContainer = type === 'random' ? randomChatMessages : joinChatMessages;
    const waitingMsg = type === 'random' ? 
        'Waiting for another user to connect' : 
        'Waiting for room host to connect';
        
    // Clear existing messages
    while (messageContainer.lastChild) {
        if (messageContainer.lastChild.classList && messageContainer.lastChild.classList.contains('waiting-animation')) {
            break;
        }
        messageContainer.removeChild(messageContainer.lastChild);
    }
    
    // Add waiting message
    const waitingElement = document.createElement('div');
    waitingElement.className = 'message system-message';
    waitingElement.id = 'waiting-message';
    waitingElement.textContent = waitingMsg;
    messageContainer.appendChild(waitingElement);
    
    // Update dots animation
    waitingInterval = setInterval(() => {
        waitingDots = (waitingDots + 1) % 4;
        let dots = '';
        for (let i = 0; i < waitingDots; i++) {
            dots += '.';
        }
        document.getElementById('waiting-message').textContent = waitingMsg + dots;
    }, 500);
    
    // Show animation
    if (type === 'random') {
        searchingAnimation.style.display = 'flex';
        messageContainer.appendChild(searchingAnimation);
    } else {
        joiningAnimation.style.display = 'flex';
        messageContainer.appendChild(joiningAnimation);
    }
    
    // Retry finding peer every 30 seconds
    setTimeout(() => {
        if (waitingForPeer) {
            if (type === 'random') {
                // Re-request a peer
                signalingSocket.send(JSON.stringify({
                    type: 'find_peer',
                    username: currentUsername,
                    useEncryption: encryptionToggle.checked,
                    useTor: torToggle.checked
                }));
            } else if (type === 'join') {
                // Re-request joining the room
                const roomCode = document.getElementById('roomCodeInput').value.trim();
                signalingSocket.send(JSON.stringify({
                    type: 'join_room',
                    username: currentUsername,
                    connectionCode: roomCode,
                    useEncryption: encryptionToggle.checked,
                    useTor: torToggle.checked
                }));
            }
            
            // Continue waiting
            startWaitingForUser(type);
        }
    }, 30000);
}

// Add function to stop waiting animation
function stopWaitingAnimation() {
    if (waitingInterval) {
        clearInterval(waitingInterval);
        waitingInterval = null;
    }
    waitingForPeer = false;
}

// Modify the strangerChatBtn event listener
strangerChatBtn.addEventListener('click', () => {
    randomChatModal.style.display = 'flex';
    
    // Reset UI
    while (randomChatMessages.firstChild) {
        randomChatMessages.removeChild(randomChatMessages.firstChild);
    }
    
    // Start waiting for a real user
    startWaitingForUser('random');
    
    // Send request to server to find peer
    signalingSocket.send(JSON.stringify({
        type: 'find_peer',
        username: currentUsername,
        useEncryption: encryptionToggle.checked,
        useTor: torToggle.checked
    }));
});

// Modify the joinRoomBtn event listener
joinRoomBtn.addEventListener('click', () => {
    const roomCode = document.getElementById('roomCodeInput').value.trim();
    if (!roomCode) return;
    
    joinRoomModal.style.display = 'flex';
    
    // Reset UI
    while (joinChatMessages.firstChild) {
        joinChatMessages.removeChild(joinChatMessages.firstChild);
    }
    
    // Start waiting animation
    startWaitingForUser('join');
    
    // Send join request
    signalingSocket.send(JSON.stringify({
        type: 'join_room',
        username: currentUsername,
        connectionCode: roomCode,
        useEncryption: encryptionToggle.checked,
        useTor: torToggle.checked
    }));
});

// Update close buttons to handle waiting state
closeRandomChat.addEventListener('click', () => {
    randomChatModal.style.display = 'none';
    stopWaitingAnimation();
    
    if (isConnectedToStranger) {
        // Send disconnect message to peer
        if (dataChannel && dataChannel.readyState === 'open') {
            try {
                const disconnectMsg = {
                    type: 'system',
                    text: 'The other party has disconnected.'
                };
                
                if (encryptionToggle.checked) {
                    const iv = generateIV();
                    disconnectMsg.text = encryptMessage(disconnectMsg.text, encryptionKey, iv);
                    disconnectMsg.iv = iv;
                }
                
                dataChannel.send(JSON.stringify(disconnectMsg));
            } catch (err) {
                console.error('Error sending disconnect message:', err);
            }
        }
        
        // Close connections
        if (dataChannel) {
            dataChannel.close();
            dataChannel = null;
        }
        
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        
        isConnectedToStranger = false;
    } else {
        // If still searching, cancel search
        signalingSocket.send(JSON.stringify({
            type: 'cancel_search',
            username: currentUsername
        }));
    }
});

closeJoinRoom.addEventListener('click', () => {
    joinRoomModal.style.display = 'none';
    stopWaitingAnimation();
    
    if (isConnectedToPrivateRoom || isJoiningRoom) {
        // Send disconnect message to peer
        if (dataChannel && dataChannel.readyState === 'open') {
            try {
                const disconnectMsg = {
                    type: 'system',
                    text: 'The other participant has disconnected.'
                };
                
                if (encryptionToggle.checked) {
                    const iv = generateIV();
                    disconnectMsg.text = encryptMessage(disconnectMsg.text, encryptionKey, iv);
                    disconnectMsg.iv = iv;
                }
                
                dataChannel.send(JSON.stringify(disconnectMsg));
            } catch (err) {
                console.error('Error sending disconnect message:', err);
            }
        }
        
        // Leave room on server
        signalingSocket.send(JSON.stringify({
            type: 'leave_room',
            roomId: currentRoomId,
            username: currentUsername
        }));
        
        // Close connections
        if (dataChannel) {
            dataChannel.close();
            dataChannel = null;
        }
        
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        
        isConnectedToPrivateRoom = false;
        isJoiningRoom = false;
        currentRoomId = '';
    }
});
        }
        </script>
    </body>
</html>
