<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>import socket
import threading
import tkinter as tk
from tkinter import scrolledtext, ttk
import random
import json
import os
import pyaudio
import time
import struct
from tkinter import messagebox

# Network settings
HOST = '0.0.0.0'  # Server will listen on all interfaces
PORT = 5555       # Text chat port
VOICE_PORT = 5556 # Voice chat port
CHUNK = 1024      # Audio chunk size
FORMAT = pyaudio.paInt16
CHANNELS = 1
RATE = 44100

# Generate a random username
ADJECTIVES = ["Happy", "Sunny", "Brave", "Bright", "Cool", "Wild", "Smart", "Swift", "Epic", "Calm"]
NOUNS = ["Tiger", "Dragon", "Phoenix", "Warrior", "Shark", "Eagle", "Wolf", "Bear", "Ninja", "Wizard"]
COLORS = ["Red", "Blue", "Green", "Yellow", "Purple", "Orange", "Pink", "Teal", "Gold", "Silver"]

def generate_username():
    return f"{random.choice(COLORS)}{random.choice(ADJECTIVES)}{random.choice(NOUNS)}"

# The main issue is likely in the VoiceClient class where audio processing happens
# Let's enhance the voice functionality to make it work properly:

class ChatClient:
    def __init__(self, host, port, username):
        self.host = host
        self.port = port
        self.username = username
        self.socket = None
        self.connected = False
        
    def connect(self):
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.host, self.port))
            
            # Send join message
            join_message = json.dumps({
                "type": "join",
                "username": self.username
            })
            self.socket.send(join_message.encode())
            
            self.connected = True
            print(f"Connected to chat server at {self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"Failed to connect to server: {e}")
            self.connected = False
            return False
    
    def send_message(self, content):
        if not self.connected or not self.socket:
            return False
            
        try:
            message = json.dumps({
                "type": "message",
                "username": self.username,
                "content": content
            })
            self.socket.send(message.encode())
            return True
        except Exception as e:
            print(f"Error sending message: {e}")
            self.connected = False
            return False
    
    def receive_messages(self, callback):
        while self.connected:
            try:
                data = self.socket.recv(4096)
                if not data:
                    break
                    
                message = json.loads(data.decode())
                
                if message["type"] == "join":
                    formatted_msg = f"--- {message['username']} has joined the chat ---"
                    callback(formatted_msg)
                    
                elif message["type"] == "message":
                    timestamp = time.strftime("%H:%M:%S")
                    formatted_msg = f"[{timestamp}] {message['username']}: {message['content']}"
                    callback(formatted_msg)
                    
                elif message["type"] == "leave":
                    formatted_msg = f"--- {message['username']} has left the chat ---"
                    callback(formatted_msg)
                    
            except Exception as e:
                print(f"Error receiving message: {e}")
                self.connected = False
                break
                
        print("Disconnected from server")
        self.connected = False
    
    def close(self):
        if self.connected and self.socket:
            try:
                # Send leave message
                leave_message = json.dumps({
                    "type": "leave",
                    "username": self.username
                })
                self.socket.send(leave_message.encode())
                
                # Close socket
                self.socket.close()
            except:
                pass
                
        self.connected = False
        self.socket = None

class VoiceClient:
    def __init__(self, host, port, username):
        self.host = host
        self.port = port
        self.username = username
        self.connected = False
        self.transmitting = False
        self.socket = None
        self.voice_users = {}  # Store voice users and their status
        self.status_callback = None  # Callback for voice user status updates
        
        # Initialize PyAudio
        self.p = pyaudio.PyAudio()
        self.input_stream = None
        self.output_stream = None
        self.transmit_thread = None
        self.receive_thread = None
        
    def set_status_callback(self, callback):
        """Set callback function for voice user status updates"""
        self.status_callback = callback
        
    def connect(self):
        try:
            print(f"Connecting to voice server at {self.host}:{self.port}")
            # Create a new PyAudio instance if needed
            if not hasattr(self, 'p') or self.p is None:
                self.p = pyaudio.PyAudio()
            
            # Close existing socket if present
            if self.socket:
                try:
                    self.socket.close()
                except:
                    pass
                
            # Create new UDP socket
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            
            # Create audio streams
            if self.input_stream:
                try:
                    self.input_stream.stop_stream()
                    self.input_stream.close()
                except:
                    pass
                    
            if self.output_stream:
                try:
                    self.output_stream.stop_stream()
                    self.output_stream.close()
                except:
                    pass
            
            # Set smaller buffer size to reduce latency
            self.input_stream = self.p.open(format=FORMAT,
                                         channels=CHANNELS,
                                         rate=RATE,
                                         input=True,
                                         frames_per_buffer=CHUNK)
            
            self.output_stream = self.p.open(format=FORMAT,
                                          channels=CHANNELS,
                                          rate=RATE,
                                          output=True,
                                          frames_per_buffer=CHUNK)
            
            print("Audio streams created successfully")
            
            # Send initial join packet to server
            join_message = json.dumps({
                "type": "join",
                "username": self.username,
                "status": "active"
            }).encode()
            self.socket.sendto(join_message, (self.host, self.port))
            print(f"Sent join message to {self.host}:{self.port}")
            
            self.connected = True
            
            # Start receiving audio
            if self.receive_thread is None or not self.receive_thread.is_alive():
                self.receive_thread = threading.Thread(target=self.receive_audio, daemon=True)
                self.receive_thread.start()
                print("Started audio reception thread")
            
            # Start transmitting automatically (open mic)
            self.transmitting = True
            if self.transmit_thread is None or not self.transmit_thread.is_alive():
                self.transmit_thread = threading.Thread(target=self.transmit_audio, daemon=True)
                self.transmit_thread.start()
                print("Started audio transmission thread")
            
            # Send a heartbeat to ensure we're registered with the server
            self.socket.sendto(json.dumps({
                "type": "heartbeat", 
                "username": self.username,
                "status": "active"  # Initially active (unmuted)
            }).encode(), (self.host, self.port))
            
            # Set socket timeout for non-blocking reception
            self.socket.settimeout(0.5)
            
            return True
        except Exception as e:
            print(f"Voice connection error: {e}")
            # Clean up on failure
            if hasattr(self, 'socket') and self.socket:
                try:
                    self.socket.close()
                    self.socket = None
                except:
                    pass
                    
            self.connected = False
            return False
    
    def toggle_mute(self):
        self.transmitting = not self.transmitting
        
        # Send mute status to server
        if self.connected and self.socket:
            try:
                status = "muted" if not self.transmitting else "active"
                self.socket.sendto(json.dumps({
                    "type": "status", 
                    "username": self.username,
                    "status": status
                }).encode(), (self.host, self.port))
                print(f"Sent mute status: {status}")
            except Exception as e:
                print(f"Error sending mute status: {e}")
                
        return self.transmitting
    
    def transmit_audio(self):
        print(f"Starting audio transmission thread")
        silent_chunk = b'\x00' * CHUNK * 2  # silent audio for when muted
        
        while self.connected:
            try:
                if self.transmitting:
                    try:
                        data = self.input_stream.read(CHUNK, exception_on_overflow=False)
                        if not data:
                            continue
                    except Exception as e:
                        print(f"Error reading from microphone: {e}")
                        data = silent_chunk
                else:
                    # When muted, just sleep briefly instead of sending silent audio
                    time.sleep(0.05)
                    continue
                
                if self.socket and self.connected:
                    try:
                        # Prepare packet with header
                        header = json.dumps({
                            "type": "audio", 
                            "username": self.username
                        }).encode()
                        header_length = struct.pack("!I", len(header))
                        
                        # Send header length, header, then audio data
                        packet = header_length + header + data
                        self.socket.sendto(packet, (self.host, self.port))
                    except Exception as e:
                        print(f"Error sending audio packet: {e}")
                        time.sleep(0.1)
                        
            except Exception as e:
                print(f"Error in transmit_audio thread: {e}")
                time.sleep(0.1)
                
        print(f"Audio transmission thread ending")
    
    def receive_audio(self):
        print(f"Starting audio reception thread")
        
        while self.connected:
            try:
                if not self.socket:
                    print("Socket not available in receive_audio")
                    time.sleep(0.5)
                    continue
                    
                try:
                    # Set timeout to prevent blocking forever
                    data, addr = self.socket.recvfrom(CHUNK * 2 + 1024)  # Extra space for header
                    
                    # Debug info
                    print(f"Received {len(data)} bytes from {addr}")
                    
                    # Check if this is a non-audio packet (control message)
                    if data.startswith(b'{'):
                        try:
                            msg = json.loads(data.decode())
                            msg_type = msg.get('type', '')
                            print(f"Received control message: {msg_type} from server")
                            
                            # Handle user list update
                            if msg_type == "user_list":
                                self.voice_users = msg.get('users', {})
                                print(f"Updated voice users: {self.voice_users}")
                                if self.status_callback:
                                    self.status_callback(self.voice_users)
                            
                            continue
                        except json.JSONDecodeError:
                            # Not valid JSON, might be part of audio data
                            pass
                    
                    # Check if we have enough data for a header
                    if len(data) < 8:  # Need at least 4 bytes for header length + some header data
                        print(f"Packet too small: {len(data)} bytes")
                        continue
                    
                    # Parse audio packet
                    try:
                        # Extract header length (first 4 bytes)
                        header_length = struct.unpack("!I", data[:4])[0]
                        
                        # Make sure we have enough data
                        if len(data) < 4 + header_length:
                            print(f"Incomplete packet: expected {4 + header_length}, got {len(data)}")
                            continue
                        
                        # Extract header and decode
                        header_data = data[4:4+header_length]
                        header = json.loads(header_data.decode())
                        sender = header.get("username", "Unknown")
                        
                        print(f"Received audio from {sender}")
                        
                        # Extract audio data
                        audio_data = data[4+header_length:]
                        
                        # Play audio if it's not from us and we have an output stream
                        if sender != self.username and self.output_stream and audio_data:
                            print(f"Playing audio from {sender} ({len(audio_data)} bytes)")
                            self.output_stream.write(audio_data)
                        
                    except Exception as e:
                        print(f"Error parsing audio packet: {str(e)}")
                        
                except socket.timeout:
                    # This is expected, just continue the loop
                    continue
                except Exception as e:
                    print(f"Error receiving audio data: {e}")
                    time.sleep(0.1)
                    
            except Exception as e:
                print(f"Error in audio receive loop: {e}")
                time.sleep(0.1)
                
        print(f"Audio reception thread ending")
    
    def close(self):
        print("Closing voice client")
        # Signal threads to terminate
        self.connected = False
        self.transmitting = False
        
        # Send leave notification if possible
        if self.socket:
            try:
                self.socket.sendto(json.dumps({
                    "type": "leave", 
                    "username": self.username
                }).encode(), (self.host, self.port))
            except:
                pass
        
        # Give threads a moment to notice the flags
        time.sleep(0.2)
        
        # Close streams
        if hasattr(self, 'input_stream') and self.input_stream:
            try:
                self.input_stream.stop_stream()
                self.input_stream.close()
                self.input_stream = None
            except Exception as e:
                print(f"Error closing input stream: {e}")
            
        if hasattr(self, 'output_stream') and self.output_stream:
            try:
                self.output_stream.stop_stream()
                self.output_stream.close()
                self.output_stream = None
            except Exception as e:
                print(f"Error closing output stream: {e}")
            
        # Close socket
        if self.socket:
            try:
                self.socket.close()
                self.socket = None
            except Exception as e:
                print(f"Error closing voice socket: {e}")
        
        # Terminate PyAudio instance
        if hasattr(self, 'p') and self.p:
            try:
                self.p.terminate()
                self.p = None
            except Exception as e:
                print(f"Error terminating PyAudio: {e}")
        
        print("Voice client closed")

# Now let's fix the VoiceServer class to handle audio properly
class VoiceServer:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.clients = {}  # Dictionary to store client info: {addr: {'username': username, 'last_seen': timestamp, 'status': status}}
        self.running = False
        self.lock = threading.Lock()
        
    def start(self):
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.socket.bind((self.host, self.port))
            self.running = True
            
            print(f"Voice server running on {self.host}:{self.port}")
            
            # Start cleanup thread to remove inactive clients
            cleanup_thread = threading.Thread(target=self.cleanup_inactive_clients, daemon=True)
            cleanup_thread.start()
            
            # Start broadcast thread to periodically send user list updates
            broadcast_thread = threading.Thread(target=self.broadcast_user_list, daemon=True)
            broadcast_thread.start()
            
            # Main server loop
            while self.running:
                try:
                    data, addr = self.socket.recvfrom(CHUNK * 2 + 1024)  # Extra space for header
                    print(f"Voice server received {len(data)} bytes from {addr}")
                    
                    # Process the received data
                    self.process_client_data(data, addr)
                except Exception as e:
                    print(f"Error in voice server main loop: {e}")
                    time.sleep(0.1)
                    
        except Exception as e:
            print(f"Voice server failed to start: {e}")
            self.running = False
    
    def process_client_data(self, data, addr):
        # Update client's last seen time
        with self.lock:
            if addr in self.clients:
                self.clients[addr]['last_seen'] = time.time()
        
        # Check if this is a join message or other control message
        if data == b"join":
            with self.lock:
                if addr not in self.clients:
                    self.clients[addr] = {
                        'username': "Unknown",
                        'last_seen': time.time(),
                        'status': 'active'  # Default to active (unmuted)
                    }
                    print(f"New voice client connected: {addr}")
                    self.broadcast_user_list_now()  # Send updated user list immediately
            return
        
        # Try to parse as JSON if it might be a control message
        if data.startswith(b'{'):
            try:
                msg = json.loads(data.decode())
                msg_type = msg.get('type', '')
                print(f"Processing voice control message: {msg_type}")
                
                if msg_type == 'join':
                    username = msg.get('username', 'Unknown')
                    status = msg.get('status', 'active')
                    with self.lock:
                        if addr not in self.clients:
                            self.clients[addr] = {
                                'username': username, 
                                'last_seen': time.time(),
                                'status': status
                            }
                        else:
                            self.clients[addr]['username'] = username
                            self.clients[addr]['last_seen'] = time.time()
                            self.clients[addr]['status'] = status
                    print(f"Voice client joined: {username} at {addr}")
                    self.broadcast_user_list_now()  # Update user list
                    return
                
                elif msg_type == 'heartbeat':
                    username = msg.get('username', 'Unknown')
                    status = msg.get('status', 'active')
                    with self.lock:
                        if addr not in self.clients:
                            self.clients[addr] = {
                                'username': username, 
                                'last_seen': time.time(),
                                'status': status
                            }
                        else:
                            self.clients[addr]['username'] = username
                            self.clients[addr]['last_seen'] = time.time()
                            self.clients[addr]['status'] = status
                    print(f"Heartbeat from {username} at {addr}")
                    # Only broadcast user list if this is a new client
                    if addr not in self.clients:
                        self.broadcast_user_list_now()
                    return
                
                elif msg_type == 'leave':
                    with self.lock:
                        if addr in self.clients:
                            username = self.clients[addr].get('username', 'Unknown')
                            print(f"Voice client {username} ({addr}) left")
                            del self.clients[addr]
                            self.broadcast_user_list_now()  # Update user list
                    return
                
                elif msg_type == 'status':
                    # Just update the client info, don't forward
                    username = msg.get('username', 'Unknown')
                    status = msg.get('status', 'unknown')
                    with self.lock:
                        if addr in self.clients:
                            self.clients[addr]['username'] = username
                            self.clients[addr]['status'] = status
                            self.clients[addr]['last_seen'] = time.time()
                    print(f"Client {username} is now {status}")
                    self.broadcast_user_list_now()  # Update user list
                    return
            except json.JSONDecodeError:
                # Not a JSON message, assume it's audio data
                pass
            except Exception as e:
                print(f"Error processing control message: {e}")
                return
        
        # Relay audio data to all other clients
        try:
            with self.lock:
                clients_copy = list(self.clients.keys())
            
            sent_count = 0
            for client_addr in clients_copy:
                if client_addr != addr:  # Don't send back to the sender
                    try:
                        self.socket.sendto(data, client_addr)
                        sent_count += 1
                    except Exception as e:
                        print(f"Error sending to client {client_addr}: {e}")
            
            print(f"Relayed audio to {sent_count} clients")
        except Exception as e:
            print(f"Error relaying audio data: {e}")
    
    def cleanup_inactive_clients(self):
        """Remove clients that haven't been seen for a while"""
        TIMEOUT = 10  # seconds
        
        while self.running:
            try:
                time.sleep(5)  # Check every 5 seconds
                
                current_time = time.time()
                to_remove = []
                
                with self.lock:
                    for addr, client_info in self.clients.items():
                        if current_time - client_info['last_seen'] > TIMEOUT:
                            to_remove.append(addr)
                    
                    if to_remove:
                        for addr in to_remove:
                            username = self.clients[addr].get('username', 'Unknown')
                            print(f"Removing inactive voice client: {username} ({addr})")
                            del self.clients[addr]
                        
                        # Broadcast updated user list if we removed anyone
                        self.broadcast_user_list_now()
                        
            except Exception as e:
                print(f"Error in cleanup thread: {e}")
    
    def broadcast_user_list(self):
        """Periodically broadcast the list of users to all clients"""
        while self.running:
            try:
                time.sleep(3)  # Update every 3 seconds
                self.broadcast_user_list_now()
            except Exception as e:
                print(f"Error in broadcast thread: {e}")
    
    def broadcast_user_list_now(self):
        """Immediately broadcast current user list to all clients"""
        try:
            # Create user list with usernames and statuses
            users = {}
            with self.lock:
                for addr, client_info in self.clients.items():
                    username = client_info.get('username', 'Unknown')
                    if username != 'Unknown':  # Only include clients with proper usernames
                        users[username] = client_info.get('status', 'active')
            
            # Create user list message
            user_list_msg = json.dumps({
                "type": "user_list",
                "users": users
            }).encode()
            
            # Send to all clients
            with self.lock:
                clients_copy = list(self.clients.keys())
            
            for client_addr in clients_copy:
                try:
                    self.socket.sendto(user_list_msg, client_addr)
                except Exception as e:
                    print(f"Error sending user list to {client_addr}: {e}")
                    
            print(f"Broadcast user list: {users}")
                    
        except Exception as e:
            print(f"Error broadcasting user list: {e}")
    
    def stop(self):
        self.running = False
        if hasattr(self, 'socket'):
            try:
                self.socket.close()
            except Exception as e:
                print(f"Error closing voice server socket: {e}")

# Add this to DiscordCloneApp class
def add_chat_message(self, username, content):
    """Add a message to the chat history"""
    self.chat_history.config(state=tk.NORMAL)
    timestamp = time.strftime("%H:%M:%S")
    self.chat_history.insert(tk.END, f"[{timestamp}] {username}: {content}\n")
    self.chat_history.see(tk.END)  # Scroll to bottom
    self.chat_history.config(state=tk.DISABLED)

class ChatServer:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.clients = []
        self.running = False
        self.lock = threading.Lock()
        
    def start(self):
        try:
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind((self.host, self.port))
            self.server_socket.listen(5)
            self.running = True
            
            print(f"Chat server running on {self.host}:{self.port}")
            
            while self.running:
                try:
                    client_socket, address = self.server_socket.accept()
                    client_thread = threading.Thread(target=self.handle_client, 
                                                   args=(client_socket, address),
                                                   daemon=True)
                    client_thread.start()
                except Exception as e:
                    print(f"Error accepting connection: {e}")
                    if not self.running:
                        break
                    time.sleep(0.1)
        except Exception as e:
            print(f"Server failed to start: {e}")
            self.running = False
            
    def handle_client(self, client_socket, address):
        username = None
        try:
            # Handle client connection
            client_info = {
                "socket": client_socket,
                "address": address,
                "username": None
            }
            
            with self.lock:
                self.clients.append(client_info)
            
            while self.running:
                data = client_socket.recv(4096)
                if not data:
                    break
                    
                message = json.loads(data.decode())
                
                if message["type"] == "join":
                    username = message["username"]
                    client_info["username"] = username
                    print(f"User joined: {username}")
                    
                    # Notify other clients
                    self.broadcast(json.dumps({
                        "type": "join",
                        "username": username
                    }), client_socket)
                    
                elif message["type"] == "message":
                    print(f"Message from {message['username']}: {message['content']}")
                    
                    # Broadcast the message to all clients
                    self.broadcast(data.decode(), None)
                    
                elif message["type"] == "leave":
                    break
                    
        except Exception as e:
            print(f"Error handling client {address}: {e}")
            
        finally:
            # Clean up and remove client
            if username:
                print(f"User left: {username}")
                self.broadcast(json.dumps({
                    "type": "leave",
                    "username": username
                }), None)
                
            try:
                client_socket.close()
            except:
                pass
            
            with self.lock:
                self.clients = [c for c in self.clients if c["socket"] != client_socket]
            
    def broadcast(self, message, exclude_socket=None):
        with self.lock:
            clients_copy = self.clients.copy()
            
        for client in clients_copy:
            # Don't send to the client who sent the message
            if exclude_socket is not client["socket"]:
                try:
                    client["socket"].send(message.encode() if isinstance(message, str) else message)
                except:
                    # Remove failed clients later
                    pass
                    
    def stop(self):
        self.running = False
        
        # Close all client connections
        with self.lock:
            clients_copy = self.clients.copy()
            
        for client in clients_copy:
            try:
                client["socket"].close()
            except:
                pass
                
        # Close server socket
        if hasattr(self, 'server_socket'):
            try:
                self.server_socket.close()
            except Exception as e:
                print(f"Error closing chat server socket: {e}")

class DiscordCloneApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Discord Clone")
        self.root.geometry("800x600")
        self.root.configure(bg="#36393f")
        
        # Generate username
        self.username = generate_username()
        
        # Try getting local IP for automatic server
        self.server_host = self.get_local_ip()
        self.running_server = True  # Always run server by default
        
        # Set up UI
        self.setup_ui()
        
        # Set up server and client
        self.setup_network()
        
        # Handle window closing
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
    def get_local_ip(self):
        try:
            # Create a dummy connection to get local IP
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "127.0.0.1"  # Fallback to localhost
            
    def setup_ui(self):
        # App theme colors (Discord-like)
        self.bg_color = "#36393f"
        self.sidebar_color = "#2f3136"
        self.text_color = "#dcddde"
        self.input_bg = "#40444b"
        self.accent_color = "#7289da"
        self.muted_color = "#ED4245"  # Red color for muted users
        
        # Configure main layout
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        
        # Main frame
        self.main_frame = tk.Frame(self.root, bg=self.bg_color)
        self.main_frame.grid(row=0, column=0, sticky="nsew")
        self.main_frame.columnconfigure(1, weight=1)
        self.main_frame.rowconfigure(0, weight=1)
        
        # Sidebar
        self.sidebar = tk.Frame(self.main_frame, width=200, bg=self.sidebar_color)
        self.sidebar.grid(row=0, column=0, sticky="ns")
        self.sidebar.grid_propagate(False)
        
        # Server info
        self.server_label = tk.Label(self.sidebar, text="Simple Discord", 
                                    font=("Arial", 14, "bold"), 
                                    bg=self.sidebar_color, fg=self.text_color)
        self.server_label.pack(pady=(15, 20))
        
        # Text channel
        tk.Label(self.sidebar, text="GLOBAL CHAT", 
                font=("Arial", 12), 
                bg=self.sidebar_color, fg=self.text_color).pack(pady=5, padx=10, anchor="w")
        
        # Voice channel section
        self.voice_section = tk.Frame(self.sidebar, bg=self.sidebar_color)
        self.voice_section.pack(pady=5, fill="x")
        
        tk.Label(self.voice_section, text="VOICE CHANNELS", 
                font=("Arial", 12), 
                bg=self.sidebar_color, fg=self.text_color).pack(pady=5, padx=10, anchor="w")
        
        # Voice channel
        self.voice_btn_frame = tk.Frame(self.voice_section, bg=self.sidebar_color)
        self.voice_btn_frame.pack(pady=5, fill="x", padx=10)
        
        tk.Label(self.voice_btn_frame, text="üîä Voice Chat", 
                font=("Arial", 12), 
                bg=self.sidebar_color, fg=self.text_color).pack(side="left")
        
        self.voice_btn = tk.Button(self.voice_btn_frame, text="Join", 
                                  bg=self.accent_color, fg="white",
                                  command=self.toggle_voice)
        self.voice_btn.pack(side="right")
        
        # Voice users frame (will be shown when voice is joined)
        self.voice_users_frame = tk.Frame(self.voice_section, bg=self.sidebar_color)
        self.voice_users_frame.pack(fill="x", padx=15, pady=5)
        
        # This will hold our voice user labels - initially empty
        self.voice_user_labels = {}
        
        # Add a label to show when no users are connected
        self.no_users_label = tk.Label(self.voice_users_frame, 
                                     text="No users in voice chat", 
                                     font=("Arial", 9, "italic"),
                                     bg=self.sidebar_color, 
                                     fg=self.text_color)
        self.no_users_label.pack(pady=5, anchor="w")
        
        # User info
        self.user_frame = tk.Frame(self.sidebar, bg="#292b2f", height=40)
        self.user_frame.pack(side="bottom", fill="x")
        
        self.user_label = tk.Label(self.user_frame, text=self.username, 
                                  font=("Arial", 10), 
                                  bg="#292b2f", fg=self.text_color)
        self.user_label.pack(pady=10, padx=10, anchor="w")
        
        # Chat area
        self.chat_frame = tk.Frame(self.main_frame, bg=self.bg_color)
        self.chat_frame.grid(row=0, column=1, sticky="nsew")
        self.chat_frame.columnconfigure(0, weight=1)
        self.chat_frame.rowconfigure(0, weight=1)
        
        # Chat history
        # Chat history
        self.chat_history = scrolledtext.ScrolledText(self.chat_frame, 
                                                    wrap=tk.WORD,
                                                    bg=self.bg_color,
                                                    fg=self.text_color,
                                                    font=("Arial", 10),
                                                    bd=0,
                                                    insertbackground=self.text_color)
        self.chat_history.grid(row=0, column=0, sticky="nsew", padx=10, pady=(10, 5))
        self.chat_history.config(state=tk.DISABLED)  # Read-only
        
        # Message input area
        self.input_frame = tk.Frame(self.chat_frame, bg=self.bg_color)
        self.input_frame.grid(row=1, column=0, sticky="ew", padx=10, pady=(0, 10))
        self.input_frame.columnconfigure(0, weight=1)
        
        self.message_input = tk.Entry(self.input_frame, 
                                    bg=self.input_bg,
                                    fg=self.text_color,
                                    font=("Arial", 10),
                                    bd=0,
                                    insertbackground=self.text_color)
        self.message_input.grid(row=0, column=0, sticky="ew", ipady=5, padx=(0, 5))
        self.message_input.bind("<Return>", self.send_message)
        
        self.send_button = tk.Button(self.input_frame, 
                                    text="Send",
                                    bg=self.accent_color,
                                    fg="white",
                                    bd=0,
                                    command=self.send_message)
        self.send_button.grid(row=0, column=1)
        
    def update_voice_user_list(self, voice_users):
        """Update the list of users in voice chat with their status"""
        # Clear existing user labels first
        for label in self.voice_user_labels.values():
            label.destroy()
        self.voice_user_labels = {}
        
        # Hide or show the "no users" label
        if not voice_users:
            self.no_users_label.pack(pady=5, anchor="w")
        else:
            self.no_users_label.pack_forget()
        
        # Add all current users
        for username, status in voice_users.items():
            # Set color based on status - red for muted, normal text color for active
            text_color = self.muted_color if status == "muted" else self.text_color
            
            # Create label with username and proper microphone icon
            icon = "üéôÔ∏è" if status == "active" else "üîá"
            user_label = tk.Label(
                self.voice_users_frame,
                text=f"{icon} {username}",
                font=("Arial", 9),
                bg=self.sidebar_color,
                fg=text_color,
                anchor="w"
            )
            user_label.pack(pady=2, fill="x", anchor="w")
            self.voice_user_labels[username] = user_label
    
    def setup_network(self):
        # Create text chat client
        self.client = ChatClient(self.server_host, PORT, self.username)
        
        # Start server if needed
        if self.running_server:
            self.start_server()
        
        # Connect to the server
        self.connect_to_server()
        
        # We don't create the voice client until the user joins voice chat
        self.in_voice_chat = False
        self.voice_client = None
    
    def start_server(self):
        # Start chat server
        self.chat_server = ChatServer(HOST, PORT)
        self.chat_server_thread = threading.Thread(target=self.chat_server.start, daemon=True)
        self.chat_server_thread.start()
        
        # Start voice server
        self.voice_server = VoiceServer(HOST, VOICE_PORT)
        self.voice_server_thread = threading.Thread(target=self.voice_server.start, daemon=True)
        self.voice_server_thread.start()
        
        self.add_system_message(f"Server running on {self.server_host}:{PORT}")
    
    def connect_to_server(self):
        if self.client.connect():
            self.receive_thread = threading.Thread(target=self.client.receive_messages, 
                                                 args=(self.on_message_received,),
                                                 daemon=True)
            self.receive_thread.start()
            
            self.add_system_message(f"Connected to server as {self.username}")
        else:
            self.add_system_message("Failed to connect to server")
    
    def add_system_message(self, message):
        """Add a system message to the chat history"""
        self.chat_history.config(state=tk.NORMAL)
        self.chat_history.insert(tk.END, f"\n--- {message} ---\n")
        self.chat_history.see(tk.END)
        self.chat_history.config(state=tk.DISABLED)
    
    def on_message_received(self, message):
        """Handle received messages from the server"""
        self.chat_history.config(state=tk.NORMAL)
        self.chat_history.insert(tk.END, f"{message}\n")
        self.chat_history.see(tk.END)
        self.chat_history.config(state=tk.DISABLED)
    
    def send_message(self, event=None):
        """Send a message to the chat"""
        message = self.message_input.get().strip()
        if message:
            if self.client.send_message(message):
                # Clear input field
                self.message_input.delete(0, tk.END)
            else:
                self.add_system_message("Failed to send message (not connected)")
    
    def toggle_voice(self):
        """Toggle joining/leaving voice chat"""
        if not hasattr(self, 'in_voice_chat') or not self.in_voice_chat:
            # Join voice chat
            if not hasattr(self, 'voice_client') or self.voice_client is None:
                self.voice_client = VoiceClient(self.server_host, VOICE_PORT, self.username)
                # Set the callback for voice status updates
                self.voice_client.set_status_callback(self.update_voice_user_list)
            
            if self.voice_client.connect():
                self.in_voice_chat = True
                self.voice_btn.config(text="Leave", bg=self.muted_color)
                
                # Add mute toggle button
                self.mute_btn = tk.Button(
                    self.voice_btn_frame, 
                    text="Mute", 
                    bg=self.accent_color, 
                    fg="white",
                    command=self.toggle_mute
                )
                self.mute_btn.pack(side="right", padx=(5, 0))
                
                self.add_system_message("You joined voice chat")
            else:
                self.add_system_message("Failed to join voice chat")
        else:
            # Leave voice chat
            if hasattr(self, 'voice_client') and self.voice_client:
                self.voice_client.close()
            
            self.in_voice_chat = False
            self.voice_btn.config(text="Join", bg=self.accent_color)
            
            # Remove mute button
            if hasattr(self, 'mute_btn') and self.mute_btn:
                self.mute_btn.destroy()
                
            # Clear voice users display
            for label in self.voice_user_labels.values():
                label.destroy()
            self.voice_user_labels = {}
            self.no_users_label.pack(pady=5, anchor="w")
            
            self.add_system_message("You left voice chat")
    
    def toggle_mute(self):
        """Toggle microphone mute status"""
        if hasattr(self, 'voice_client') and self.voice_client and self.in_voice_chat:
            is_transmitting = self.voice_client.toggle_mute()
            
            if is_transmitting:
                self.mute_btn.config(text="Mute", bg=self.accent_color)
                self.add_system_message("Microphone unmuted")
            else:
                self.mute_btn.config(text="Unmute", bg=self.muted_color)
                self.add_system_message("Microphone muted")
    
    def on_closing(self):
        """Handle window closing event"""
        # Stop client connections
        if hasattr(self, 'client'):
            self.client.close()
        
        if hasattr(self, 'voice_client') and self.voice_client:
            self.voice_client.close()
        
        # Stop servers if running
        if hasattr(self, 'chat_server_thread') and self.chat_server_thread.is_alive():
            self.chat_server.stop()
            
        if hasattr(self, 'voice_server_thread') and self.voice_server_thread.is_alive():
            self.voice_server.stop()
        
        # Destroy the window
        self.root.destroy()

# Main function to run the app
def main():
    root = tk.Tk()
    app = DiscordCloneApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()</h1>
</body>
</html>
